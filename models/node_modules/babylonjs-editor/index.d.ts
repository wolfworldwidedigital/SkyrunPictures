// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../@blueprintjs/core
//   ../../flexlayout-react
//   ../../babylonjs
//   ../../react
//   ../../directory-tree
//   ../../adm-zip
//   ../../@blueprintjs/select
//   renderer/editor/graph/node.d.ts
//   ../../xterm
//   ../../node-pty

declare module 'babylonjs-editor' {
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export { IPluginAssets } from "babylonjs-editor/renderer/editor/plugins/assets";
    export { IPluginToolbar } from "babylonjs-editor/renderer/editor/plugins/toolbar";
    export { IPluginGraph, IPluginGraphNode } from "babylonjs-editor/renderer/editor/plugins/graph";
    export { IPlugin, IPluginConfiguration } from "babylonjs-editor/renderer/editor/plugins/plugin";
    export { AbstractEditorPlugin, IEditorPluginProps } from "babylonjs-editor/renderer/editor/tools/plugin";
    export { Editor } from "babylonjs-editor/renderer/editor/editor";
    export { Tools } from "babylonjs-editor/renderer/editor/tools/tools";
    export { IPCTools } from "babylonjs-editor/renderer/editor/tools/ipc";
    export { FSTools } from "babylonjs-editor/renderer/editor/tools/fs";
    export { Assets, IAssetComponent, IAssetsProps, IAssetsState } from "babylonjs-editor/renderer/editor/components/assets";
    export { AbstractAssets, IAbstractAssets, IAssetComponentItem, IAssetsComponentProps, IAssetsComponentState } from "babylonjs-editor/renderer/editor/assets/abstract-assets";
    export { AssetsBrowserMoveHandler } from "babylonjs-editor/renderer/editor/components/assets-browser/files/move/move-handler";
    export { AssetsBrowserItemHandler, IAssetsBrowserItemHandlerProps, IAssetsBrowserItemHandlerState, IItemHandler } from "babylonjs-editor/renderer/editor/components/assets-browser/files/item-handler";
    export { MaterialAssets } from "babylonjs-editor/renderer/editor/assets/materials";
    export { TextureAssets } from "babylonjs-editor/renderer/editor/assets/textures";
    export { Inspector, IInspectorProps, IInspectorState, IObjectInspector, IObjectInspectorProps } from "babylonjs-editor/renderer/editor/components/inspector";
    export { AbstractInspector } from "babylonjs-editor/renderer/editor/components/inspectors/abstract-inspector";
    export { MaterialInspector, IMaterialInspectorState } from "babylonjs-editor/renderer/editor/components/inspectors/materials/material-inspector";
    export { InspectorColor } from "babylonjs-editor/renderer/editor/gui/inspector/fields/color";
    export { InspectorButton } from "babylonjs-editor/renderer/editor/gui/inspector/fields/button";
    export { InspectorNumber } from "babylonjs-editor/renderer/editor/gui/inspector/fields/number";
    export { InspectorString } from "babylonjs-editor/renderer/editor/gui/inspector/fields/string";
    export { InspectorBoolean } from "babylonjs-editor/renderer/editor/gui/inspector/fields/boolean";
    export { InspectorSection } from "babylonjs-editor/renderer/editor/gui/inspector/fields/section";
    export { InspectorVector2 } from "babylonjs-editor/renderer/editor/gui/inspector/fields/vector2";
    export { InspectorVector3 } from "babylonjs-editor/renderer/editor/gui/inspector/fields/vector3";
    export { InspectorNotifier } from "babylonjs-editor/renderer/editor/gui/inspector/notifier";
    export { InspectorColorPicker } from "babylonjs-editor/renderer/editor/gui/inspector/fields/color-picker";
    export { InspectorList, IInspectorListItem } from "babylonjs-editor/renderer/editor/gui/inspector/fields/list";
    export { GraphNode, CodeGenerationExecutionType, CodeGenerationOutputType, ELinkErrorType, ICodeGenerationOutput, INodeContextMenuOption } from "babylonjs-editor/renderer/editor/graph/node";
    export { FilesStore, IContentFile, IFile } from "babylonjs-editor/renderer/editor/project/files";
    export { IBabylonFile, IBabylonFileNode, IProject, IWorkSpace } from "babylonjs-editor/renderer/editor/project/typings";
    export { ProjectExporter } from "babylonjs-editor/renderer/editor/project/project-exporter";
    export { Project } from "babylonjs-editor/renderer/editor/project/project";
    export { WorkSpace } from "babylonjs-editor/renderer/editor/project/workspace";
    export { SceneExporter } from "babylonjs-editor/renderer/editor/project/scene-exporter";
    export { MeshExporter } from "babylonjs-editor/renderer/editor/export/mesh";
    export { GeometryExporter } from "babylonjs-editor/renderer/editor/export/geometry";
    export { Alert, IAlertProps } from "babylonjs-editor/renderer/editor/gui/alert";
    export { Dialog, IDialogProps } from "babylonjs-editor/renderer/editor/gui/dialog";
    export { Confirm, IConfirmProps } from "babylonjs-editor/renderer/editor/gui/confirm";
    export { Icon } from "babylonjs-editor/renderer/editor/gui/icon";
    export { SceneImporterTools, ISceneImporterToolsConfiguration } from "babylonjs-editor/renderer/editor/scene/import-tools";
    export { Packer, IPackerOptions, PackerStatus } from "babylonjs-editor/renderer/editor/project/packer/packer";
    export let editor: Editor | null;
}

declare module 'babylonjs-editor/renderer/editor/editor' {
    import { IStringDictionary, Nullable, Undefinable } from "babylonjs-editor/shared/types";
    import { Toaster, Intent, IconName, MaybeElement } from "@blueprintjs/core";
    import { Layout, Rect } from "flexlayout-react";
    import { Engine, Scene, Observable, ISize, Node, BaseTexture, Material, SubMesh, IParticleSystem, Sound, KeyboardInfo, Skeleton, ReflectionProbe } from "babylonjs";
    import { IObjectModified, IEditorPreferences, EditorPlayMode } from "babylonjs-editor/renderer/editor/tools/types";
    import { AbstractEditorPlugin } from "babylonjs-editor/renderer/editor/tools/plugin";
    import { SceneUtils } from "babylonjs-editor/renderer/editor/scene/utils";
    import { PostProcessAssets } from "babylonjs-editor/renderer/editor/scene/post-processes";
    import { IPlugin } from "babylonjs-editor/renderer/editor/plugins/plugin";
    import "./scene/register";
    import "./painting/material-mixer/material";
    import { Inspector } from "babylonjs-editor/renderer/editor/components/inspector";
    import { Graph } from "babylonjs-editor/renderer/editor/components/graph";
    import { Assets } from "babylonjs-editor/renderer/editor/components/assets";
    import { AssetsBrowser } from "babylonjs-editor/renderer/editor/components/assets-browser";
    import { Preview } from "babylonjs-editor/renderer/editor/components/preview";
    import { MainToolbar } from "babylonjs-editor/renderer/editor/components/main-toolbar";
    import { ToolsToolbar } from "babylonjs-editor/renderer/editor/components/tools-toolbar";
    import { Console } from "babylonjs-editor/renderer/editor/components/console";
    import "./components/inspectors/scene/scene-inspector";
    import "./components/inspectors/scene/rendering-inspector";
    import "./components/inspectors/scene/animation-groups-inspector";
    import "./components/inspectors/node-inspector";
    import "./components/inspectors/node/mesh-inspector";
    import "./components/inspectors/node/transform-node-inspector";
    import "./components/inspectors/node/sub-mesh-proxy-inspector";
    import "./components/inspectors/node/sub-mesh-inspector";
    import "./components/inspectors/node/ground-inspector";
    import "./components/inspectors/node/skeleton-inspector";
    import "./components/inspectors/lights/light-inspector";
    import "./components/inspectors/lights/directional-light-inspector";
    import "./components/inspectors/lights/spot-light-inspector";
    import "./components/inspectors/lights/point-light-inspector";
    import "./components/inspectors/lights/hemispheric-light-inspector";
    import "./components/inspectors/lights/shadows-inspector";
    import "./components/inspectors/cameras/camera-inspector";
    import "./components/inspectors/cameras/free-camera-inspector";
    import "./components/inspectors/cameras/arc-rotate-camera-inspector";
    import "./components/inspectors/cameras/target-camera-inspector";
    import "./components/inspectors/cameras/post-process-inspector";
    import "./components/inspectors/materials/standard-inspector";
    import "./components/inspectors/materials/pbr-inspector";
    import "./components/inspectors/materials/pbr-metallic-rougness-inspector";
    import "./components/inspectors/materials/sky-inspector";
    import "./components/inspectors/materials/node-inspector";
    import "./components/inspectors/materials/cell-inspector";
    import "./components/inspectors/materials/fire-inspector";
    import "./components/inspectors/materials/lava-inspector";
    import "./components/inspectors/materials/water-inspector";
    import "./components/inspectors/materials/gradient-inspector";
    import "./components/inspectors/materials/tri-planar-inspector";
    import "./components/inspectors/materials/grid-inspector";
    import "./components/inspectors/textures/texture-inspector";
    import "./components/inspectors/textures/texture-file-inspector";
    import "./components/inspectors/particle-systems/particle-system-inspector";
    import "./components/inspectors/particle-systems/particle-system-gradients-inspector";
    import "./components/inspectors/sound/sound-inspector";
    import "./components/inspectors/textures/reflection-probe-inspector";
    export interface ILayoutTabNodeConfiguration {
            /**
                * Defines the name of the layout tab node.
                */
            componentName: "preview" | "inspector" | "console" | "assets" | "graph" | string;
            /**
                * Defines the name of the tab component.
                */
            name: string;
            /**
                * Defines the id of the layout tab node.
                */
            id: string;
            /**
                * Defines the id of the tab node in the layout.
                */
            rect: Rect;
    }
    export class Editor {
            /**
                * Reference to the Babylon.JS engine used to render the preview scene.
                */
            engine: Nullable<Engine>;
            /**
                * Reference to the Babylon.JS scene rendered by the preview component.
                */
            scene: Nullable<Scene>;
            /**
                * Reference to the layout used to create the editor's sections.
                */
            layout: Layout;
            /**
                * Reference to the inspector tool used to edit objects in the scene.
                */
            inspector: Inspector;
            /**
                * Reference to the graph tool used to show and edit hierarchy in the scene..
                */
            graph: Graph;
            /**
                * Reference to the assets tool used to show and edit assets of the project (meshes, prefabs, etc.)..
                */
            assets: Assets;
            /**
                * Reference to the preview element used to draw the project's scene.
                */
            preview: Preview;
            /**
                * Reference to the main toolbar.
                */
            mainToolbar: MainToolbar;
            /**
                * Reference to the tools toolbar.
                */
            toolsToolbar: ToolsToolbar;
            /**
                * Reference to the console.
                */
            console: Console;
            /**
                * Defines the reference to the assets browser component.
                */
            assetsBrowser: AssetsBrowser;
            /**
                * Defines the dictionary of all avaiable loaded plugins in the editor.
                */
            plugins: IStringDictionary<AbstractEditorPlugin<any>>;
            /**
                * Reference to the scene utils.
                */
            sceneUtils: SceneUtils;
            /**
                * Defines the reference to the post-processes assets.
                */
            postProcesses: PostProcessAssets;
            /**
                * Notifies observers once the editor has been initialized.
                */
            editorInitializedObservable: Observable<void>;
            /**
                * Notifies observers on the editor is resized (window, layout, etc.).
                */
            resizeObservable: Observable<void>;
            /**
                * Notifies observers on the editor modified an object (typically inspectors).
                */
            objectModifiedObservable: Observable<IObjectModified<any>>;
            /**
                * Notifies observers on the editor modfies an object (typically inspectors).
                */
            objectModigyingObservable: Observable<IObjectModified<any>>;
            /**
                * Notifies observers that a node has been selected in the editor (preview or graph).
                */
            selectedNodeObservable: Observable<Node>;
            /**
                * Notifies observers that a submesh has been selected in the editor (preview or graph).
                */
            selectedSubMeshObservable: Observable<SubMesh>;
            /**
                * Notifies observers that a particle system has been selected in the editor (preview or graph).
                */
            selectedParticleSystemObservable: Observable<IParticleSystem>;
            /**
                * Notifies observers that a reflection probe has been selected in the editor (preview or graph).
                */
            selectedReflectionProbeObservable: Observable<ReflectionProbe>;
            /**
                * Notifies observers that a texture has been selected in the editor (assets).
                */
            selectedTextureObservable: Observable<BaseTexture>;
            /**
                * Notifies observers that a material has been selected in the editor (assets).
                */
            selectedMaterialObservable: Observable<Material>;
            /**
                * Notifies observers that the scene has been selected in the editor (graph).
                */
            selectedSceneObservable: Observable<Scene>;
            /**
                * Notifies observers that a sound has been selected in the editor (graph, preview).
                */
            selectedSoundObservable: Observable<Sound>;
            /**
                * Notifies observers that a skeleton has been selected in the editor (graph).
                */
            selectedSkeletonObservable: Observable<Skeleton>;
            /**
                * Notifies observers that a node has been added in the editor.
                */
            addedNodeObservable: Observable<Node>;
            /**
                * Notifies observers that a particle system has been added in the editor.
                */
            addedParticleSystemObservable: Observable<IParticleSystem>;
            /**
                * Notifies observers that a sound has been added in the editor.
                */
            addedSoundObservable: Observable<Sound>;
            /**
                * Notifies observers that a node has been removed in the editor (graph, preview, etc.).
                */
            removedNodeObservable: Observable<Node>;
            /**
                * Notifies observers that a particle system has been removed in the editor (graph, preview, etc.).
                */
            removedParticleSystemObservable: Observable<IParticleSystem>;
            /**
                * Notifies observers that a sound has been removed in the editor (graph, preview, etc.).
                */
            removedSoundObservable: Observable<Sound>;
            /**
                * Notifies observers that a keyboard event has been fired.
                */
            keyboardEventObservable: Observable<KeyboardInfo>;
            /**
                * Notifies observers that the project will be saved.
                */
            beforeSaveProjectObservable: Observable<string>;
            /**
                * Notifies observers that the project has been saved.
                */
            afterSaveProjectObservable: Observable<string>;
            /**
                * Notifies observers that the scene will be generated.
                */
            beforeGenerateSceneObservable: Observable<string>;
            /**
                * Notifies observers that the scene has been generated.
                */
            afterGenerateSceneObservable: Observable<string>;
            /**
                * Defines the current editor version.
                * @hidden
                */
            _packageJson: any;
            /**
                * @hidden
                */
            _byPassBeforeUnload: boolean;
            /**
                * @hidden
                */
            _toaster: Nullable<Toaster>;
            /**
                * Defines the dictionary of all configurations for all tab nodes. This configuration is updated each time a node
                * event is triggered, like "resize".
                * @hidden
                */
            readonly _layoutTabNodesConfigurations: Record<string, ILayoutTabNodeConfiguration>;
            /**
                * Defines the current version of the layout.
                */
            static readonly LayoutVersion = "4.1.0";
            /**
                * Defines the dictionary of all loaded plugins in the editor.
                */
            static LoadedPlugins: IStringDictionary<{
                    name: string;
                    fullPath?: boolean;
            }>;
            /**
                * Defines the dictionary of all loaded external plugins in the editor.
                */
            static LoadedExternalPlugins: IStringDictionary<IPlugin>;
            /**
                * Constructor.
                */
            constructor();
            /**
                * Called on the component did mount.
                */
            init(): Promise<void>;
            /**
                * Resizes the editor.
                */
            resize(): void;
            /**
                * Returns wether or not the editor has been initialized.
                */
            get isInitialized(): boolean;
            /**
                * Returns wether or not the project is fully ready.
                */
            get isProjectReady(): boolean;
            /**
                * Returns the current size of the panel identified by the given id.
                * @param panelId the id of the panel to retrieve its size.
                */
            getPanelSize(panelId: string): ISize;
            /**
                * Adds a new task feedback (typically when saving the project).
                * @param amount the amount of progress for the task in interval [0; 100].
                * @param message the message to show.
                */
            addTaskFeedback(amount: number, message: string, timeout?: number): string;
            /**
                * Updates the task feedback identified by the given key.
                * @param key the key that identifies the task feedback.
                * @param amount the new amount of the progress bar.
                * @param message the new message to show.
                */
            updateTaskFeedback(key: string, amount: number, message?: string): void;
            /**
                * Closes the toast identified by the given id.
                * @param key the key of the existing toast.
                * @param timeout the time in Ms to wait before dismiss.
                */
            closeTaskFeedback(key: string, timeout?: number): void;
            /**
                * Notifies the user the given message.
                * @param message defines the message to notify.
                * @param timeout defines the time in ms before hidding the notification.
                * @param icon odefines the ptional icon to show in the toast.
                * @param intent defines the visual intent color.
                */
            notifyMessage(message: string, timeout?: number, icon?: IconName | MaybeElement, intent?: Intent): void;
            /**
                * Adds a new plugin to the layout.
                * @param name the name of the plugin to laod.
                * @param openParameters defines the optional reference to the opening parameters.
                */
            addBuiltInPlugin(name: string, openParameters?: any): void;
            /**
                * Adds the given plugin to the editor's layout.
                * @param path defines the path of the plugin.
                * @param openParameters defines the optional reference to the opening parameters.
                */
            addPluginFromPath(path: string, openParameters?: any): void;
            /**
                * Closes the plugin identified by the given name.
                * @param pluginName the name of the plugin to close.
                */
            closePlugin(pluginName: string): void;
            /**
                * Adds a new plugin handled by its own window.
                * @param name defines the name of the plugin to load.
                * @param tabbed defines wether or not the window should be added in a tab (works only on MacOS).
                * @param windowId defines the id of the window that is possibly already opened.
                * @param args defines the optional arguments to pass the plugn's .init function.
                */
            addWindowedPlugin(name: string, tabbed: boolean, windowId?: Undefinable<number>, ...args: any[]): Promise<Nullable<number>>;
            /**
                * Adds a new preview.
                */
            addPreview(): void;
            /**
                * Runs the project.
                * @param integratedBrowser defines wether or not the integrated browser should be used to run the project.
                * @param https defines wether or not an HTTPS server should be used to serve the project.
                */
            runProject(mode: EditorPlayMode, https: boolean): Promise<void>;
            /**
                * Reveals the panel identified by the given Id.
                * @param panelId the id of the panel to reveal.
                */
            revealPanel(panelId: string): void;
            /**
                * Returns the current settings of the editor.
                */
            getPreferences(): IEditorPreferences;
            /**
                * Sets wether or not the editor's scene should be rendered.
                * @param render defines wether or not the render loop should render the editor's scene.
                */
            runRenderLoop(render: boolean, clear?: boolean): void;
            /**
                * Shows the tag identified by the given name.
                * @param tabName defines the name of the tab to show.
                */
            showTab(tabName: string): void;
            /**
                * Saves the editor configuration.
                * @hidden
                */
            _saveEditorConfig(): void;
            /**
                * Resets the editor.
                * @hidden
                */
            _resetEditor(): void;
            /**
                * Called by the workspace settings windows.
                * @hidden
                */
            _refreshWorkSpace(): Promise<void>;
            /**
                * @hidden
                */
            _applyPreferences(): Promise<void>;
            /**
                * @hidden
                */
            _applyPreferencesPlugins(): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/plugins/assets' {
    import { Undefinable } from "babylonjs-editor/shared/types";
    import { IItemHandler } from "babylonjs-editor/renderer/editor/components/assets-browser/files/item-handler";
    import { AssetsBrowserMoveHandler } from "babylonjs-editor/renderer/editor/components/assets-browser/files/move/move-handler";
    export interface IPluginAssets {
            /**
                * Defines the item handler to register in the assets-browser component of the editor.
                */
            itemHandler?: Undefinable<IItemHandler>;
            /**
                * Defines the move item handler to register in the assets-browser component of the editor.
                * This handler will be called each time a file that matches the handler extension has been moved.
                */
            moveItemhandler?: Undefinable<AssetsBrowserMoveHandler>;
    }
}

declare module 'babylonjs-editor/renderer/editor/plugins/toolbar' {
    import * as React from "react";
    import { IconName, MaybeElement } from "@blueprintjs/core";
    export interface IPluginToolbar {
            /**
                * Defines the label of the button to draw in the toolbar.
                */
            buttonLabel: React.ReactNode;
            /**
                * Defines the name of the icon for the plugin.
                */
            buttonIcon: IconName | MaybeElement;
            /**
                * Defines the content of the menu in the toolbar.
                * @example
                *  import { Menu, MenuItem, MenuDivider } from "@blueprintjs/core";
                *  <Menu>
                            <MenuItem text="Add..." icon="add" onClick={() => ...} />
                            <MenuDivider />
                            <MenuItem text="Remove..." icon="remove" onClick={() => ...} />
                    </Menu>
                */
            content: JSX.Element;
    }
}

declare module 'babylonjs-editor/renderer/editor/plugins/graph' {
    import { Undefinable } from "babylonjs-editor/shared/types";
    import { GraphNode } from "babylonjs-editor/renderer/editor/graph/node";
    export interface IPluginGraphNode {
            /**
                * Defines the path of the graph node in the node creator menu.
                * @example "custom/my_node" which gives "Custom -> My Node".
                */
            creatorPath: string;
            /**
                * Defines the reference to the constructor of the node.
                * The constructor can't take any
                */
            ctor: new () => GraphNode;
    }
    export interface IPluginGraph {
            /**
                * Defines the list of all graph nodes to register when the plugin has been loaded.
                */
            nodes?: Undefinable<IPluginGraphNode[]>;
    }
}

declare module 'babylonjs-editor/renderer/editor/plugins/plugin' {
    import { Undefinable } from "babylonjs-editor/shared/types";
    import { IObjectInspector } from "babylonjs-editor/renderer/editor/components/inspector";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { IPluginAssets } from "babylonjs-editor/renderer/editor/plugins/assets";
    import { IPluginToolbar } from "babylonjs-editor/renderer/editor/plugins/toolbar";
    export interface IPluginConfiguration {
            /**
                * Defines the absolute path of the plugin.
                */
            pluginAbsolutePath: string;
    }
    export interface IPlugin {
            /**
                * Defines the list of all toolbar elements to add when the plugin has been loaded.
                */
            toolbar?: Undefinable<IPluginToolbar[]>;
            /**
                * Defines the list of all inspectors to register when the plugin has been loaded.
                */
            inspectors?: Undefinable<IObjectInspector[]>;
            /**
                * Defines the list of all assets handlers to register when the plugin has been loaded.
                */
            assets?: Undefinable<IPluginAssets[]>;
            /**
                * If implemented, should return an object (plain JSON object) that will be saved
                * in the workspace file. This will be typically used to store preferences of the plugin
                * work a given workspace and not globally.
                * If implemented, the preferences will be saved in the .editorworkspace file each time the user
                * saves the project.
                */
            getWorkspacePreferences?: () => any;
            /**
                * When the plugin saved preferences (@see .getWorkspacePreferences) this function
                * will be called giving the plain JSON representation of the user's preferences for
                * the current plugin.
                */
            setWorkspacePreferences?: (preferences: any) => void;
            /**
                * Called on the plugin is being disposed.
                */
            onDispose?: () => void;
    }
    /**
        * Defines the signature of the function that is exported by the editor's plugin.
        */
    export type registerEditorPlugin = (editor: Editor, configuration: IPluginConfiguration) => IPlugin;
}

declare module 'babylonjs-editor/renderer/editor/tools/plugin' {
    import * as React from "react";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface IEditorPluginProps {
            /**
                * Defines the reference of the editor be used in the plugin.
                */
            editor: Editor;
            /**
                * Defines the id of the plugin.
                */
            id: string;
            /**
                * Defines the optional reference to the opening parameters.
                */
            openParameters?: any;
    }
    export abstract class AbstractEditorPlugin<T> extends React.Component<IEditorPluginProps, T> {
            /**
                * The editor reference.
                */
            protected editor: Editor;
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IEditorPluginProps);
            /**
                * Renders the component.
                */
            abstract render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
            /**
                * Called on the panel has been resized.
                * @param width the new with of the plugin's panel.
                * @param height the new height of the plugin's panel.
                */
            resize(width: number, height: number): void;
            /**
                * Called on the plugin was previously hidden and is now shown.
                */
            onShow(): void;
            /**
                * Called on the plugin was previously visible and is now hidden.
                */
            onHide(): void;
            /**
                * Called on the plugin is ready.
                */
            abstract onReady(): void;
            /**
                * Called on the plugin is closed.
                */
            abstract onClose(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/tools/tools' {
    import { Engine, Scene, Node, Camera, Mesh, Material } from "babylonjs";
    import { ICommonMetadata, IEditorPreferences, IMaterialMetadata, IMeshMetadata, ITransformNodeMetadata } from "babylonjs-editor/renderer/editor/tools/types";
    export class Tools {
            /**
                * Normalizes the given path according to the current platform.
                * @param path defines the path to normalize according to the current platform.
                */
            static NormalizePathForCurrentPlatform(path: string): string;
            /**
                * Returns the name of the constructor of the given object.
                * @param object the object to return its constructor name.
                */
            static GetConstructorName(object: any): string;
            /**
                * Returns the metadatas of the given node.
                * @param node defines the reference to the node to get its metadatas.
                */
            static GetNodeMetadata(node: Node): ICommonMetadata;
            /**
                * Returns the metadatas of the given mesh.
                * @param mesh defines the reference to the mesh to get its metadatas.
                */
            static GetMeshMetadata(mesh: Mesh): IMeshMetadata;
            /**
                * Returns the metadatas of the given transform node.
                * @param transformNode defines the reference to the transform node to get its metadatas.
                */
            static GetTransformNodeMetadata(transformNode: Mesh): ITransformNodeMetadata;
            /**
                * Returns the metadatas of the given material.
                * @param material defines the reference to the material to get its metadatas.
                */
            static GetMaterialMetadata(material: Material): IMaterialMetadata;
            /**
                * Returns the absolute path to the attached JS file or the given TS file.
                * @param workspaceDir defines the absolute path to the workspace.
                * @param relativePath defines the relative path of the TS file to get its JS source file path.
                * @returns the absolute path to the attached JS file.
                */
            static GetSourcePath(workspaceDir: string, relativePath: string): string;
            /**
                * Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
                * Be aware Math.random() could cause collisions, but:
                * "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
                */
            static RandomId(): string;
            /**
                * Returns all the scene nodes of the given scene.
                * @param scene the scene containing the nodes to get.
                */
            static getAllSceneNodes(scene: Scene): Node[];
            /**
                * Returns wether or not the given element is a child (recursively) of the given parent.
                * @param element the element being possibily a child of the given parent.
                * @param parent the parent to check.
                */
            static IsElementChildOf(element: HTMLElement, parent: HTMLElement): boolean;
            /**
                * Waits until the given timeMs value is reached.
                * @param timeMs the time in milliseconds to wait.
                */
            static Wait(timeMs: number): Promise<void>;
            /**
                * Waits for the next animation frame.
                */
            static WaitNextAnimationFrame(): Promise<void>;
            /**
                * Returns the given array by keeping only distinct values.
                * @param array the array to filter.
                */
            static Distinct<T>(array: T[]): T[];
            /**
                * Sorts the given array alphabetically.
                * @param array defines the array containing the elements to sort alphabetically.
                * @param property in case of an array of objects, this property will be used to get the right value to sort.
                */
            static SortAlphabetically(array: any[], property?: string): any[];
            /**
                * Deeply clones the given object.
                * @param object the object reference to clone.
                * @warning take care of cycle dependencies!
                */
            static CloneObject<T>(object: T): T;
            /**
                * Returns the property of the given object at the given path..
                * @param object defines the object reference containing the property to get.
                * @param path defines the path of the property to get;
                */
            static GetProperty<T>(object: any, path: string): T;
            /**
                * Returns the effective property of the given object at the given path..
                * @param object defines the object reference containing the property to get.
                * @param path the path of the property to get.
                */
            static GetEffectiveProperty<T>(object: any, path: string): T;
            /**
                * Returns the saved editor preferences (zoom, etc.).
                */
            static GetEditorPreferences(): IEditorPreferences;
            /**
                * Creates a screenshot of the current scene.
                * @param engine the engine used to render the scene to take as screenshot.
                * @param camera the camera that should be used for the screenshot.
                */
            static CreateScreenshot(engine: Engine, camera: Camera): Promise<string>;
            /**
                * Shows the open file dialog and returns the selected file.
                */
            static ShowNativeOpenFileDialog(): Promise<File>;
            /**
                * Shows the open multiple files dialog and returns the selected files.
                */
            static ShowNativeOpenMultipleFileDialog(): Promise<File[]>;
            /**
                * Returns the extension attached to the given mime type.
                * @param mimeType the mitype to check.
                */
            static GetExtensionFromMimeType(mimeType: string): string;
            /**
                * Reads the given file as array buffer.
                * @param file the file to read and return its content as array buffer.
                */
            static ReadFileAsArrayBuffer(file: File | Blob): Promise<ArrayBuffer>;
            /**
                * Loads a file from a url.
                * @param url the file url to load.
                * @param useArrayBuffer defines a boolean indicating that date must be returned as ArrayBuffer.
                * @param onProgress callback called while file is loading (if the server supports this mode).
                */
            static LoadFile<T = string | ArrayBuffer>(url: string, useArrayBuffer: boolean, onProgress?: (data: any) => void): Promise<T>;
    }
}

declare module 'babylonjs-editor/renderer/editor/tools/ipc' {
    export class IPCTools {
            /**
                * Calls the host with the given request and arguments.
                * @param request the name of the request to send to host.
                * @param args the arguments to send to host.
                * @warning should be called only for requests that send responses.
                */
            static CallWithPromise<T>(request: string, ...args: any[]): Promise<T>;
            /**
                * Sends the given data to the window id with the given message id.
                * @param popupId the id of the window to send the message.
                * @param id the id of the message.
                * @param data the data to send to the window.
                */
            static SendWindowMessage<T>(popupId: number, id: string, data?: any): Promise<{
                    id: string;
                    data: T;
            }>;
            /**
                * Executes the given action in the main editor window with the given arguments.
                * @param args the editor's function arguments.
                * @warning take care with arguments.
                */
            static ExecuteEditorFunction<T>(functionName: string, ...args: any[]): Promise<{
                    id: string;
                    data: T;
            }>;
            /**
                * Sends the given parameters with the given request to the host.
                * @param request the name of the request to send to host.
                * @param args the arguments to send to host.
                */
            static Send(request: string, ...args: any[]): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/tools/fs' {
    import { DirectoryTree } from "directory-tree";
    export class FSTools {
            /**
                * Creates the directory at the given absolute path. If the directory already exists, nothing is done.
                * @param path defines the absolute path to the directory to create.
                */
            static CreateDirectory(path: string): Promise<void>;
            /**
                * Flattens the list of files available (recursively) in the given directory path.
                * @param directoryPath defines the path to the directory to recursively get its files.
                * @param ignore defines the array of folders/files to ignore.
                * @returns the list of all files located (recursively) in the given directory path.
                */
            static GetGlobFiles(directoryPath: string, ignore?: string[]): Promise<string[]>;
            /**
                * Returns the tree of all available directories and files in the given directory path.
                * @param directoryPath defines the absolute path to the directory to get its tree.
                * @returns the tree of all available directories and files in the given directory path.
                */
            static GetDirectoryTree(directoryPath: string): DirectoryTree;
            /**
                * Removes the given directory recursively.
                * @param directoryPath defines the absolute path to the directory to remove.
                */
            static RemoveDirectory(directoryPath: string): Promise<void>;
            /**
                * Waits until the given file (absolute path) exists.
                * @param filePath defines the absolute path to the file to test until it exists.
                * @param timeout defines the optional timeout to resolve the promise @default 10000
                */
            static WaitUntilFileExists(filePath: string, timeout?: number): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/assets' {
    import * as React from "react";
    import { TabId } from "@blueprintjs/core";
    import { Nullable, Undefinable } from "babylonjs-editor/shared/types";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { AbstractAssets, IAssetComponentItem } from "babylonjs-editor/renderer/editor/assets/abstract-assets";
    export interface IAssetComponent {
            /**
                * The title of the assets component.
                */
            title: string;
            /**
                * Defines the identifier of the component.
                */
            identifier: string;
            /**
                * Constructor reference of the component.
                */
            ctor: (new (props: IAssetsProps) => AbstractAssets);
            /**
                * @hidden
                */
            _id?: string;
            /**
                * @hidden
                */
            _ref?: AbstractAssets;
    }
    export interface IAssetsProps {
            /**
                * The editor reference to be used in the assets component.
                */
            editor: Editor;
    }
    export interface IAssetsState {
            /**
                * Defines the Id of the active tab.
                */
            activeTabId?: TabId;
    }
    export class Assets extends React.Component<IAssetsProps, IAssetsState> {
            /**
                * Adds the given component to the assets stack.
                * @param component the component to add in the assets stack.
                */
            static addAssetComponent(component: IAssetComponent): void;
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IAssetsProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Selects (activates) the tab of the given assets component.
                * @param component defines the component to show.
                */
            selectTab(component?: (new (props: IAssetsProps) => AbstractAssets)): void;
            /**
                * Refreshes all the assets.
                * @param component defines the component to refresh.
                * @param object defines the object to refresh.
                */
            refresh<T>(component?: (new (props: IAssetsProps) => AbstractAssets), object?: Undefinable<T>): Promise<void>;
            /**
                * Forces refreshing all assets.
                * @param component the component to force refresh.
                */
            forceRefresh(component?: (new (props: IAssetsProps) => AbstractAssets)): Promise<void>;
            /**
                * Clears all the unused assets by removing their files.
                */
            clearUnusedAssets(): Promise<void>;
            /**
                * Resizes the assets components.
                */
            resize(): void;
            /**
                * Returns all the assets of the given assets component.
                * @param componentCtor the component to get its assets already computed.
                */
            getAssetsOf(componentCtor: (new (props: IAssetsProps) => AbstractAssets)): Undefinable<IAssetComponentItem[]>;
            /**
                * Returns all the assets of the component identified by the given Id.
                * @param id defines the id of the assets component to get its assets.
                */
            getAssetsOfComponentId(id: string): IAssetComponentItem[];
            /**
                * Returns the reference of the given assets component.
                * @param componentCtor the component to get its reference.
                */
            getComponent<T extends AbstractAssets>(componentCtor: (new (props: IAssetsProps) => T)): Nullable<T>;
            /**
                * Returns the list of all assets components.
                */
            getAssetsComponents(): IAssetComponent[];
    }
}

declare module 'babylonjs-editor/renderer/editor/assets/abstract-assets' {
    import * as React from "react";
    import { PickingInfo, Observable, Node, Scene } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { Nullable, Undefinable } from "babylonjs-editor/shared/types";
    export interface IAssetsComponentProps {
            /**
                * The editor reference to be used in the assets component.
                */
            editor: Editor;
            /**
                * The id of the component.
                */
            id: string;
            /**
                * Optional callback called on the user double clicks an asset.
                */
            onClick?: Undefinable<(item: IAssetComponentItem, img: HTMLImageElement) => void>;
            /**
                * Optional callback called on the user double clicks an asset.
                */
            doubleClick?: Undefinable<(item: IAssetComponentItem, img: HTMLImageElement) => void>;
            /**
                * Optional style to apply.
                */
            style?: Undefinable<React.CSSProperties>;
    }
    export interface IAssetComponentItem {
            /**
                * Defines the id of the texture.
                */
            id: string;
            /**
                * Defines the preview of the texture in base64.
                */
            base64: string;
            /**
                * The key string used by React.
                */
            key: string;
            /**
                * Optional style that can be added to the item node.
                */
            ref?: Nullable<HTMLDivElement>;
            /**
                * Optional style options for the div.
                */
            style?: Undefinable<React.CSSProperties>;
            /**
                * Defines wether or not the item is selected.
                */
            isSelected?: Undefinable<boolean>;
            /**
                * Defines wether or not popover is enabled.
                */
            popoverEnabled?: Undefinable<boolean>;
            /**
                * Defines the extra data describing the asset item.
                */
            extraData?: {
                    [index: string]: number | string | boolean;
            };
    }
    export interface IDragAndDroppedAssetComponentItem extends IAssetComponentItem {
            /**
                * Defines the id of the component containing the asset being drag'n'dropped.
                */
            assetComponentId: string;
    }
    export interface IAssetsComponentState {
            /**
                * Defines all the assets to draw in the panel.
                */
            items: IAssetComponentItem[];
            /**
                * Defines the height of the panel.
                */
            height: number;
    }
    export interface IAbstractAssets {
            /**
                * Refreshes the component.
                * @param object the optional object reference that has been modified in the editor.
                */
            refresh<T>(object: Undefinable<T>): Promise<void>;
            /**
                * Called on the user drops an asset in editor. (typically the preview canvas).
                * @param item the item being dropped.
                * @param pickInfo the pick info generated on the drop event.
                */
            onDropAsset(item: IAssetComponentItem, pickInfo: PickingInfo): void;
            /**
                * Called on an asset item has been drag'n'dropped on graph component.
                * @param data defines the data of the asset component item being drag'n'dropped.
                * @param nodes defines the array of nodes having the given item being drag'n'dropped.
                */
            onGraphDropAsset?(data: IAssetComponentItem, nodes: (Scene | Node)[]): boolean;
    }
    export class AbstractAssets extends React.Component<IAssetsComponentProps, IAssetsComponentState> implements IAbstractAssets {
            /**
                * Defines the reference to the drag'n'dropped item.
                * @hidden
                */
            static _DragAndDroppedItem: Nullable<AbstractAssets>;
            /**
                * Defines the list of all available assets.
                */
            items: IAssetComponentItem[];
            /**
                * Defines the observable used to notify observers that an asset has been updated.
                */
            updateAssetObservable: Observable<void>;
            /**
                * The editor reference.
                */
            protected editor: Editor;
            /**
                * Defines the size of assets to be drawn in the panel. Default is 100x100 pixels.
                */
            protected size: number;
            /**
                * Defines the type of the data transfer data when drag'n'dropping asset.
                */
            readonly dragAndDropType: string;
            /**
                * Stores the current list of nodes drawn in the panel..
                * @warning should be used with care.
                */
            protected _itemsNodes: React.ReactNode[];
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IAssetsComponentProps);
            /**
                * Refreshes the component.
                */
            refresh(): Promise<void>;
            /**
                * Called once a project has been loaded, this function is used to clean up
                * unused assets files automatically.
                */
            clean(): Promise<void>;
            /**
                * Called on the user starts dragging the item.
                * @param ev defines the reference to the drag event.
                * @param item defines the reference to the dragged item.
                */
            onDragStart(_1: React.DragEvent<HTMLImageElement>, _2: IAssetComponentItem): void;
            /**
                * Called on the user drops an asset in editor. (typically the preview canvas).
                * @param item the item being dropped.
                * @param pickInfo the pick info generated on the drop event.
                */
            onDropAsset(_: IAssetComponentItem, __: PickingInfo): void;
            /**
                * Called on the user drops the asset in a supported inspector field.
                * @param ev defiens the reference to the event object.
                * @param object defines the reference to the object being modified in the inspector.
                * @param property defines the property of the object to assign the asset instance.
                */
            onDropInInspector(_1: React.DragEvent<HTMLElement>, _2: any, _3: string): Promise<void>;
            /**
                * Called on the user double clicks an item.
                * @param item the item being double clicked.
                * @param img the double-clicked image element.
                */
            onDoubleClick(item: IAssetComponentItem, img: HTMLImageElement): void;
            /**
                * Called on the user clicks on an item.
                * @param item the item being clicked.
                * @param img the clicked image element.
                */
            onClick(item: IAssetComponentItem, img: HTMLImageElement): void;
            /**
                * Called on the user right-clicks on an item.
                * @param item the item being right-clicked.
                * @param event the original mouse event.
                */
            onContextMenu(_: IAssetComponentItem, event: React.MouseEvent<HTMLImageElement, MouseEvent>): void;
            /**
                * Called on the user right-clicks on the component's main div.
                * @param event the original mouse event.
                */
            onComponentContextMenu(_: React.MouseEvent<HTMLDivElement, MouseEvent>): void;
            /**
                * Called on the user pressed the delete key on the asset.
                * @param item defines the item being deleted.
                */
            onDeleteAsset(_: IAssetComponentItem): void;
            /**
                * Called on an asset item has been drag'n'dropped on graph component.
                * @param data defines the data of the asset component item being drag'n'dropped.
                * @param nodes defines the array of nodes having the given item being drag'n'dropped.
                */
            onGraphDropAsset(_: IAssetComponentItem, __: (Scene | Node)[]): boolean;
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Sets the new filter on the user wants to filter the assets.
                * @param filter the new filter to search assets.
                */
            setFilter(filter: string): void;
            /**
                * Resizes the element.
                */
            resize(): void;
            /**
                * Updates the given item thumbnail.
                * @param key defines the key (identifier) or the item to update.
                * @param base64 defines the new base64 value of the thumbnail.
                */
            updateAssetThumbnail(key: string, base64: string): void;
            /**
                * Returns the current item that is being dragged.
                */
            protected get itemBeingDragged(): Nullable<IAssetComponentItem>;
            /**
                * Returns the content of the item's tooltip on the pointer is over the given item.
                * @param item defines the reference to the item having the pointer over.
                */
            protected getItemTooltipContent(_: IAssetComponentItem): Undefinable<JSX.Element>;
            /**
                * Called on the user starts dragging the asset.
                */
            protected dragStart(ev: React.DragEvent<HTMLImageElement>, item: IAssetComponentItem): void;
            /**
                * Called on the currently dragged item is over the given item.
                * @param item the item having the currently dragged item over.
                */
            protected dragEnter(_: IAssetComponentItem): void;
            /**
                * Called on the currently dragged item is out the given item.
                * @param item the item having the currently dragged item out.
                */
            protected dragLeave(_: IAssetComponentItem): void;
            /**
                * Called on the currently dragged item has been dropped.
                * @param item the item having the currently dragged item dropped over.
                * @param droppedItem the item that has been dropped.
                */
            protected dropOver(_: IAssetComponentItem, __: IAssetComponentItem): void;
            /**
                * Called on the user ends dragging the asset.
                * @param e defines the reference to the drag'n'drop event.
                */
            protected dragEnd(e: React.DragEvent<HTMLImageElement>): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/assets-browser/files/move/move-handler' {
    export abstract class AssetsBrowserMoveHandler {
            /**
                * Defines the list of all extensions handled by the item mover.
                */
            abstract extensions: string[];
            /**
                * Returns wether or not the asset located at the given path is used in the project.
                * @param path defines the absolute path to the file.
                */
            abstract isFileUsed(path: string): Promise<boolean>;
            /**
                * Called on the user moves the given file from the previous path to the new path.
                * @param from defines the previous absolute path to the file being moved.
                * @param to defines the new absolute path to the file being moved.
                */
            abstract moveFile(from: string, to: string): void | Promise<void>;
            /**
                * Returns wheter or not the given file can be renamed.
                * @param from defines the previous absolute path to the file being renamed.
                * @param to defines the new absolute path to the file being renamed.
                */
            canRename(_from: string, _to: string): Promise<boolean>;
            /**
                * Called on the given file is being remvoed.
                * @param path defines the absolute path to the file that is being removed.
                */
            onRemoveFile(_: string): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/assets-browser/files/item-handler' {
    import { IStringDictionary, Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { PickingInfo } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { IAssetFileConfiguration } from "babylonjs-editor/renderer/editor/project/typings";
    import { IWorkerConfiguration } from "babylonjs-editor/renderer/editor/workers/workers";
    export interface IAssetsBrowserItemHandlerProps {
            /**
                * Defines the reference to the editor.
                */
            editor: Editor;
            /**
                * Defines the relative path to the item.
                */
            relativePath: string;
            /**
                * Defines the absolute path to the item.
                */
            absolutePath: string;
            /**
                * Defines the type of the item (directory or file).
                */
            type: "file" | "directory";
            /**
                * Defines the callback called on the item is starts being dragged.
                */
            onDragStart: (ev: React.DragEvent<HTMLDivElement>) => void;
            /**
                * Defines the callback caleld on the item handler wants to change the color of the title.
                * This is useful to target assets types.
                */
            onSetTitleColor: (color: string) => void;
    }
    export interface IAssetsBrowserItemHandlerState {
            /**
                * Defines the reference to the preview image to be drawn in the item.
                */
            previewImage: Nullable<React.ReactNode>;
    }
    export interface IItemHandler {
            /**
                * Defines the extension supported by the handler.
                */
            extension: string;
            /**
                * Defines the function called each time an asset that matches the extension
                * is being added to the items list of the assets component.
                */
            ctor: (new (props: IAssetsBrowserItemHandlerProps) => AssetsBrowserItemHandler);
    }
    export abstract class AssetsBrowserItemHandler extends React.Component<IAssetsBrowserItemHandlerProps, IAssetsBrowserItemHandlerState> {
            /**
                * Defines the reference to the assets worker.
                */
            static AssetWorker: IWorkerConfiguration;
            /**
                * Defines the reference to the object that collects the configuration of all assets available
                * in the workspace. The key represents the releative path to the file and the value the configuration
                * of the asset. This is typically used to let the user choose how to handle the assets during the export.
                */
            static AssetsConfiguration: IStringDictionary<IAssetFileConfiguration>;
            /**
                * Initialzes the item handler.
                */
            static Init(): Promise<void>;
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IAssetsBrowserItemHandlerProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): Promise<void>;
            /**
                * Computes the image to render as a preview.
                */
            abstract computePreview(): React.ReactNode | Promise<React.ReactNode>;
            /**
                * Refreshes the preview thumbnail of the asset.
                */
            _handleRefreshPreview(): Promise<void>;
            /**
                * Called on the user clicks on the asset.
                * @param ev defines the reference to the event object.
                */
            onClick(_: React.MouseEvent<HTMLDivElement, MouseEvent>): void;
            /**
                * Called on the user double clicks on the item.
                * @param ev defines the reference to the event object.
                */
            onDoubleClick(_: React.MouseEvent<HTMLDivElement, MouseEvent>): void;
            /**
                * Called on the user right clicks on the item.
                * @param ev defines the reference to the event object.
                */
            onContextMenu(_: React.MouseEvent<HTMLDivElement, MouseEvent>): void;
            /**
                * Called on the user starts dragging the item.
                * @param ev defines the reference to the event object.
                */
            onDragStart(_: React.DragEvent<HTMLDivElement>): void;
            /**
                * Called on the user drops the asset in the editor's preview canvas.
                * @param ev defines the reference to the event object.
                * @param pick defines the picking info generated while dropping in the preview.
                */
            onDropInPreview(_1: DragEvent, _2: PickingInfo): void;
            /**
                * Called on the user drops the asset in a supported inspector field.
                * @param ev defiens the reference to the event object.
                * @param object defines the reference to the object being modified in the inspector.
                * @param property defines the property of the object to assign the asset instance.
                */
            onDropInInspector(_1: React.DragEvent<HTMLElement>, _2: any, _3: string): Promise<void>;
            /**
                * Called on the user drops the asset in the editor's graph.
                * @param ev defines the reference to the event object.
                * @param objects defines the reference to the array of objects selected in the graph.
                */
            onDropInGraph(_1: React.DragEvent<HTMLElement>, _2: any[]): Promise<void>;
            /**
                * Returns the list of all common context menu items.
                */
            protected getCommonContextMenuItems(): React.ReactNode[];
    }
}

declare module 'babylonjs-editor/renderer/editor/assets/materials' {
    import Zip from "adm-zip";
    import { Nullable, Undefinable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Material, PickingInfo, Scene, Node } from "babylonjs";
    import { AbstractAssets, IAssetComponentItem } from "babylonjs-editor/renderer/editor/assets/abstract-assets";
    import "../tools/materials/augmentations";
    export class MaterialAssets extends AbstractAssets {
            /**
                * Defines the type of the data transfer data when drag'n'dropping asset.
                * @override
                */
            readonly dragAndDropType: string;
            /**
                * Registers the component.
                */
            static Register(): void;
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Refreshes the component.
                * @override
                */
            refresh(): Promise<void>;
            /**
                * Called on the user clicks on an item.
                * @param item the item being clicked.
                * @param img the clicked image element.
                */
            onClick(item: IAssetComponentItem, img: HTMLImageElement): void;
            /**
                * Called on the user right-clicks on an item.
                * @param item the item being right-clicked.
                * @param event the original mouse event.
                */
            onContextMenu(item: IAssetComponentItem, e: React.MouseEvent<HTMLImageElement, MouseEvent>): void;
            /**
                * Called on the user starts dragging the item.
                * @param ev defines the reference to the drag event.
                */
            onDragStart(ev: React.DragEvent<HTMLImageElement>, item: IAssetComponentItem): void;
            /**
                * Called on the user drops the asset in a supported inspector field.
                * @param ev defiens the reference to the event object.
                * @param object defines the reference to the object being modified in the inspector.
                * @param property defines the property of the object to assign the asset instance.
                */
            onDropInInspector(ev: React.DragEvent<HTMLElement>, object: any, property: string): Promise<void>;
            /**
                * Called on the user drops an asset in editor. (typically the preview canvas).
                * @param item the item being dropped.
                * @param pickInfo the pick info generated on the drop event.
                * @override
                */
            onDropAsset(item: IAssetComponentItem, pickInfo: PickingInfo): Promise<void>;
            /**
                * Called on the user pressed the delete key on the asset.
                * @param item defines the item being deleted.
                */
            onDeleteAsset(item: IAssetComponentItem): void;
            /**
                * Called on an asset item has been drag'n'dropped on graph component.
                * @param data defines the data of the asset component item being drag'n'dropped.
                * @param nodes defines the array of nodes having the given item being drag'n'dropped.
                */
            onGraphDropAsset(data: IAssetComponentItem, nodes: (Scene | Node)[]): boolean;
            /**
                * Returns the content of the item's tooltip on the pointer is over the given item.
                * @param item defines the reference to the item having the pointer over.
                */
            protected getItemTooltipContent(item: IAssetComponentItem): Undefinable<JSX.Element>;
            /**
                * Saves the given material as zip and returns its zip reference.
                * @param materialId the id of the material to save as zip.
                */
            getZippedMaterial(materialId: string): Nullable<Zip>;
            /**
                * Loads a material preset from the given preset path.
                * @param path the absolute path of the material preset.
                */
            loadMaterialFromZip(path: string): Nullable<Material>;
            /**
                * Opens the given material in a separated window.
                * @param material defines the reference to the material to open.
                */
            openMaterial(material: Material): Promise<void>;
            /**
                * Returns, if found, the item in assets related to the given material.
                * @param material defines the reference to the material to retrieve its asset item.
                */
            getAssetFromMaterial(material: Material): Nullable<IAssetComponentItem>;
            /**
                * Called on the user wants to save the material.
                * @param item the item select when the user wants to save a material.
                */
            _handleSaveMaterialPreset(item: IAssetComponentItem): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/assets/textures' {
    import { Undefinable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { PickingInfo } from "babylonjs";
    import { AbstractAssets, IAssetComponentItem } from "babylonjs-editor/renderer/editor/assets/abstract-assets";
    export class TextureAssets extends AbstractAssets {
            /**
                * Defines the size of assets to be drawn in the panel. Default is 100x100 pixels.
                * @override
                */
            protected size: number;
            /**
                * Registers the component.
                */
            static Register(): void;
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Refreshes the component.
                * @override
                */
            refresh(): Promise<void>;
            /**
                * Called on the user clicks on an item.
                * @param item the item being clicked.
                * @param img the clicked image element.
                */
            onClick(item: IAssetComponentItem, img: HTMLImageElement): void;
            /**
                * Called on the user double clicks an item.
                * @param item the item being double clicked.
                * @param img the double-clicked image element.
                */
            onDoubleClick(item: IAssetComponentItem, img: HTMLImageElement): Promise<void>;
            /**
                * Called on the user right-clicks on an item.
                * @param item the item being right-clicked.
                * @param event the original mouse event.
                */
            onContextMenu(item: IAssetComponentItem, e: React.MouseEvent<HTMLImageElement, MouseEvent>): void;
            /**
                * Called on the user starts dragging the item.
                * @param ev defines the reference to the drag event.
                */
            onDragStart(ev: React.DragEvent<HTMLImageElement>, item: IAssetComponentItem): void;
            /**
                * Called on the user drops the asset in a supported inspector field.
                * @param ev defiens the reference to the event object.
                * @param object defines the reference to the object being modified in the inspector.
                * @param property defines the property of the object to assign the asset instance.
                */
            onDropInInspector(ev: React.DragEvent<HTMLElement>, object: any, property: string): Promise<void>;
            /**
                * Called on the user drops an asset in editor. (typically the preview canvas).
                * @param item the item being dropped.
                * @param pickInfo the pick info generated on the drop event.
                * @override
                */
            onDropAsset(item: IAssetComponentItem, pickInfo: PickingInfo): void;
            /**
                * Called on the user pressed the delete key on the asset.
                * @param item defines the item being deleted.
                */
            onDeleteAsset(item: IAssetComponentItem): void;
            /**
                * In case of using compressed textures, refreshes the associoated compressed textures
                * files for each existing texture in the project.
                */
            refreshCompressedTexturesFiles(): Promise<void>;
            /**
                * Returns the content of the item's tooltip on the pointer is over the given item.
                * @param item defines the reference to the item having the pointer over.
                */
            protected getItemTooltipContent(item: IAssetComponentItem): Undefinable<JSX.Element>;
            /**
                * Called on the user wants to add a pure cube texture.
                */
            _addPureCubeTexture(): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/inspector' {
    import { Undefinable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { AbstractInspector } from "babylonjs-editor/renderer/editor/components/inspectors/abstract-inspector";
    export interface IObjectInspector {
            ctor: (new (props: IObjectInspectorProps) => AbstractInspector<any, any>);
            ctorNames: string[];
            title: string;
            isSupported?: Undefinable<(obj: any) => boolean>;
            /**
                * The reference to the inspector.
                * @hidden
                */
            _ref?: Undefinable<AbstractInspector<any, any>>;
            /**
                * @hidden
                */
            _id?: Undefinable<string>;
    }
    export interface IObjectInspectorProps {
            /**
                * Defines the editor reference.
                */
            editor: Editor;
            /**
                * Defines the id of the tool.
                */
            toolId: string;
            /**
                * The object reference to edit.
                * @hidden
                */
            _objectRef: any;
    }
    export interface IInspectorProps {
            /**
                * Defines the editor reference.
                */
            editor: Editor;
    }
    export interface IInspectorState {
            /**
                * Defines the reference to the selected object in the editor.
                */
            selectedObject: any;
            /**
                * Defines the number of times the component has been refreshed.
                */
            refreshCount: number;
            /**
                * Defines wether or not the inspector is locked. When locked, inspector will not be updated
                * according to newly selected objects but stays on the last selected one. Once unlocked, updates
                * the inspector the currently selected object in the graph.
                */
            isLocked: boolean;
    }
    export class Inspector extends React.Component<IInspectorProps, IInspectorState> {
            /**
                * The selected object reference.
                */
            selectedObject: any;
            /**
                * Registers the given object inspector.
                * @param objectInspectorConfiguration the object inspector configuration.
                */
            static RegisterObjectInspector(objectInspectorConfiguration: IObjectInspector): void;
            /**
                * Removes the given object inspector configuration from the available object inspectors.
                * @param objectInspectorConfiguration defines the object inspector configuration to remove.
                */
            static UnregisterObjectInspector(objectInspectorConfiguration: IObjectInspector): void;
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IInspectorProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Forces the update of the component.
                * @param callback defines the callback called on the update is done.
                */
            forceUpdate(callback?: (() => void) | undefined): void;
            /**
                * Catches exceptions generated in descendant components.
                * Unhandled exceptions will cause the entire component tree to unmount.
                */
            componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void;
            /**
                * Sets the selected object in the scene or graph to be edited.
                * @param object the selected object reference used by the inspector to be modified.
                */
            setSelectedObject<T>(object: T): void;
            /**
                * Refreshes the inspector.
                */
            refresh(): void;
            /**
                * Resizes the inspector.
                */
            resize(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/inspectors/abstract-inspector' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Texture, Material, ISize, BaseTexture } from "babylonjs";
    import { IObjectInspectorProps } from "babylonjs-editor/renderer/editor/components/inspector";
    import { IInspectorListItem } from "babylonjs-editor/renderer/editor/gui/inspector/fields/list";
    import { IInspectorNotifierUndoRedo } from "babylonjs-editor/renderer/editor/gui/inspector/utils";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export abstract class AbstractInspector<T, S> extends React.Component<IObjectInspectorProps, S> {
            /**
                * Defines wether or not undo/redo should be handled by the inspector.
                */
            handleUndoRedo: boolean;
            /**
                * Defines the reference to the editor.
                */
            protected editor: Editor;
            /**
                * Defines the reference to the edited root object (node, sound, etc.).
                */
            protected selectedObject: T;
            /**
                * @hidden
                */
            protected readonly _inspectorName: string;
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IObjectInspectorProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
            /**
                * Forces the update of the component.
                * @param callback defines the callback called on the update is done.
                */
            forceUpdate(callback?: (() => void) | undefined): void;
            /**
                * Gets wether or not the component is mounted.
                */
            get isMounted(): boolean;
            /**
                * Resizes the inspector.
                * @param size defines the new size of the panel.
                */
            resize(size?: ISize): void;
            /**
                * Renders the content of the inspector.
                */
            abstract renderContent(): React.ReactNode;
            /**
                * Called on a property of the selected object has changed.
                */
            onPropertyChanged(_?: IInspectorNotifierUndoRedo<any>): void;
            /**
                * Returns the list of available textures in the assets to be drawn.
                */
            getTexturesList(predicate?: (t: BaseTexture) => unknown): IInspectorListItem<Nullable<Texture>>[];
            /**
                * Returns the list of available materials in the assets to be drawn.
                */
            getMaterialsList(): IInspectorListItem<Nullable<Material>>[];
            /**
                * Gets all nodes in the current scene, or returns an empty array if no scene.
                */
            getSceneNodes(allowedType?: "TransformNode" | "Mesh" | "Light" | "Camera" | "AbstractMesh"): IInspectorListItem<string>[];
    }
}

declare module 'babylonjs-editor/renderer/editor/components/inspectors/materials/material-inspector' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Material, Mesh, SubMesh } from "babylonjs";
    import { IExportedInspectorValue } from "babylonjs-editor/renderer/sandbox/main";
    import { IObjectInspectorProps } from "babylonjs-editor/renderer/editor/components/inspector";
    import { AbstractInspector } from "babylonjs-editor/renderer/editor/components/inspectors/abstract-inspector";
    export interface IMaterialInspectorState {
            /**
                * Defines the list of all exported values in case of a custom material.
                */
            exportedValues?: IExportedInspectorValue[];
    }
    export class MaterialInspector<T extends Material, S extends IMaterialInspectorState = IMaterialInspectorState> extends AbstractInspector<Material | Mesh | SubMesh, S> {
            /**
                * Returns wether or not the selected object in the editor is supported to edit material.
                * @param o defines the object being selected in the editor.
                */
            static IsObjectSupported(o: any, materialCtor: (new (...args: any[]) => Material)): boolean;
            /**
                * Returns the material of the given object (material, mesh, sub mesh, etc;).
                * @param o defines the reference to the object to get its material.
                */
            static GetMaterialOfObject(o: any): Nullable<Material>;
            /**
                * Defines the reference to the selected material.
                */
            protected material: T;
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IObjectInspectorProps);
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
            /**
                * Called on a property of the selected object has changed.
                */
            onPropertyChanged(): void;
            /**
                * Renders the content of the inspector.
                */
            renderContent(): React.ReactNode;
            /**
                * Returns the inspector used to edit the flags of the material.
                */
            protected getMaterialFlagsInspector(): React.ReactNode;
            /**
                * Returns the inspector used to configure the advanced properties such as alpha mode etc.
                */
            protected getAdvancedOptionsInspector(): React.ReactNode;
            /**
                * Returns the inspector used to edit all the material's properties that are tagged "@visibleInInspector".
                */
            protected getInspectableValuesInspector(): React.ReactNode;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/color' {
    import * as React from "react";
    export interface IColor4Like {
            /**
                * Defines the value of the red channel.
                */
            r: number;
            /**
                * Defines the value of the green channel.
                */
            g: number;
            /**
                * Defines the value of the blue channel.
                */
            b: number;
            /**
                * Defines the value of the alpha channel.
                */
            a?: number;
    }
    export interface IInspectorColorProps {
            /**
                * Defines the reference to the object to modify.
                */
            object: any;
            /**
                * Defines the property to edit in the object.
                */
            property: string;
            /**
                * Defines the label of the field.
                */
            label: string;
            /**
                * Defines the step used when dragging the mouse.
                */
            step?: number;
            /**
                * Defines the optional callback called on the value changes.
                * @param value defines the new value of the object's property.
                */
            onChange?: (value: IColor4Like) => void;
            /**
                * Defines the optional callack called on the value finished changes.
                * @param value defines the new value of the object's property.
                */
            onFinishChange?: (value: IColor4Like) => void;
    }
    export interface IInspectorColorState {
            /**
                * Defines the current value of the input.
                */
            value: IColor4Like;
    }
    export class InspectorColor extends React.Component<IInspectorColorProps, IInspectorColorState> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorColorProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/button' {
    import * as React from "react";
    import { IconName, MaybeElement } from "@blueprintjs/core";
    export interface IInspectorButtonProps {
            /**
                * Defines the label of the button.
                */
            label: string;
            /**
                * Defines wether or not the button will be small.
                */
            small?: boolean;
            /**
                * Defines wether or not the button is disabled.
                */
            disabled?: boolean;
            /**
                * Defines the optional icon of the button.
                */
            icon?: IconName | MaybeElement;
            /**
                * Defines the optional callback called on the button is clicked.
                */
            onClick?: () => void;
    }
    export class InspectorButton extends React.Component<IInspectorButtonProps> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorButtonProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/number' {
    import * as React from "react";
    import { AbstractFieldComponent } from "babylonjs-editor/renderer/editor/gui/inspector/fields/abstract-field";
    export interface IInspectorNumberProps {
            /**
                * Defines the reference to the object to modify.
                */
            object: any;
            /**
                * Defines the property to edit in the object.
                */
            property: string;
            /**
                * Defines the label of the field.
                */
            label: string;
            /**
                * Defines the step used when dragging the mouse.
                */
            step?: number;
            /**
                * Defines the minimum value of the input.
                */
            min?: number;
            /**
                * Defines the maximum value of the input.
                */
            max?: number;
            /**
                * Defines wether or not the slider should be visible in case of a min and a max value.
                */
            noSlider?: boolean;
            /**
                * Defines wether or not the label should be hidden.
                */
            noLabel?: boolean;
            /**
                * Defines the default value of the field in case the editor property doesn't exist.
                */
            defaultValue?: number;
            /**
                * Defines wether or not automatic undo/redo should be skipped.
                */
            noUndoRedo?: boolean;
            /**
                * Defines the optional callback called on the value changes.
                * @param value defines the new value of the object's property.
                */
            onChange?: (value: number) => void;
            /**
                * Defines the optional callack called on the value finished changes.
                * @param value defines the new value of the object's property.
                * @param oldValue defines the old value of the property before it has been changed.
                */
            onFinishChange?: (value: number, oldValue: number) => void;
    }
    export interface IInspectorNumberState {
            /**
                * Defines the current value of the input.
                */
            value: string;
    }
    export class InspectorNumber extends AbstractFieldComponent<IInspectorNumberProps, IInspectorNumberState> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorNumberProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/string' {
    import * as React from "react";
    import { AbstractFieldComponent } from "babylonjs-editor/renderer/editor/gui/inspector/fields/abstract-field";
    export interface IInspectorStringProps {
            /**
                * Defines the reference to the object to modify.
                */
            object: any;
            /**
                * Defines the property to edit in the object.
                */
            property: string;
            /**
                * Defines the label of the field.
                */
            label: string;
            /**
                * Defines wether or not automatic undo/redo should be skipped.
                */
            noUndoRedo?: boolean;
            /**
                * Defines the optional callback called on the value changes.
                * @param value defines the new value of the object's property.
                */
            onChange?: (value: string) => void;
            /**
                * Defines the optional callack called on the value finished changes.
                * @param value defines the new value of the object's property.
                * @param oldValue defines the old value of the edited string property.
                */
            onFinishChange?: (value: string, oldValue: string) => void;
    }
    export interface IInspectorStringState {
            /**
                * Defines the current value of the input.
                */
            value: string;
    }
    export class InspectorString extends AbstractFieldComponent<IInspectorStringProps, IInspectorStringState> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorStringProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/boolean' {
    import * as React from "react";
    import { AbstractFieldComponent } from "babylonjs-editor/renderer/editor/gui/inspector/fields/abstract-field";
    export interface IInspectorBooleanProps<T> {
            /**
                * Defines the reference to the object to modify.
                */
            object: T;
            /**
                * Defines the property to edit in the object.
                */
            property: string;
            /**
                * Defines the label of the field.
                */
            label: string;
            /**
                * Defines the default value in case of possible undefined/null value.
                */
            defaultValue?: boolean;
            /**
                * Defines wether or not automatic undo/redo should be skipped.
                */
            noUndoRedo?: boolean;
            /**
                * Defines the optional callback called on the value changes.
                * @param value defines the new value of the object's property.
                */
            onChange?: (value: boolean) => void;
            /**
                * Defines the optional callack called on the value finished changes.
                * @param value defines the new value of the object's property.
                * @param oldValue defines the old value of the property before it has been changed.
                */
            onFinishChange?: (value: boolean, oldValue: boolean) => void;
    }
    export interface IInspectorBooleanState {
            /**
                * Defines the current value of the input.
                */
            value: boolean;
            /**
                * Defines the color of the div on the mouse is over/out the switch.
                */
            overColor: string;
    }
    export class InspectorBoolean<T> extends AbstractFieldComponent<IInspectorBooleanProps<T>, IInspectorBooleanState> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorBooleanProps<T>);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/section' {
    import * as React from "react";
    import { MaybeElement } from "@blueprintjs/core";
    export interface IInspectorSectionProps {
            /**
                * Defines the title of the section shown as a header.
                */
            title: string;
            /**
                * Defines the optional icon of the section.
                */
            icon?: MaybeElement;
            /**
                * Defines wether or not the section is collapsed.
                */
            collapsed?: boolean;
    }
    export interface IInspectorSectionState {
            /**
                * Defines the current height of the callout.
                */
            collapsed: boolean;
            /**
                * Defines wether or not the section is visible.
                */
            visible: boolean;
    }
    export class InspectorSection extends React.Component<IInspectorSectionProps, IInspectorSectionState> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorSectionProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/vector2' {
    import * as React from "react";
    export interface IVector2Like {
            /**
                * Defines the value of the X axis.
                */
            x: number;
            /**
                * Defines the value of the Y axis.
                */
            y: number;
    }
    export interface IInspectorVector2Props {
            /**
                * Defines the reference to the object to modify.
                */
            object: any;
            /**
                * Defines the property to edit in the object.
                */
            property: string;
            /**
                * Defines the label of the field.
                */
            label: string;
            /**
                * Defines the minimum value of the input.
                */
            min?: number;
            /**
                * Defines the maximum value of the input.
                */
            max?: number;
            /**
                * Defines the step used when dragging the mouse.
                */
            step?: number;
            /**
                * Defines the optional callback called on the value changes.
                * @param value defines the new value of the object's property.
                */
            onChange?: (value: IVector2Like) => void;
            /**
                * Defines the optional callack called on the value finished changes.
                * @param value defines the new value of the object's property.
                */
            onFinishChange?: (value: IVector2Like) => void;
    }
    export interface IInspectorVector2State {
            /**
                * Defines the current value of the input.
                */
            value: IVector2Like;
    }
    export class InspectorVector2 extends React.Component<IInspectorVector2Props, IInspectorVector2State> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorVector2Props);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/vector3' {
    import * as React from "react";
    export interface IVector3Like {
            /**
                * Defines the value of the X axis.
                */
            x: number;
            /**
                * Defines the value of the Y axis.
                */
            y: number;
            /**
                * Defines the value on the Z axis.
                */
            z: number;
    }
    export interface IInspectorVector3Props {
            /**
                * Defines the reference to the object to modify.
                */
            object: any;
            /**
                * Defines the property to edit in the object.
                */
            property: string;
            /**
                * Defines the label of the field.
                */
            label: string;
            /**
                * Defines the minimum value of the input.
                */
            min?: number;
            /**
                * Defines the maximum value of the input.
                */
            max?: number;
            /**
                * Defines the step used when dragging the mouse.
                */
            step?: number;
            /**
                * Defines wether or not automatic undo/redo should be skipped.
                */
            noUndoRedo?: boolean;
            /**
                * Defines the optional callback called on the value changes.
                * @param value defines the new value of the object's property.
                */
            onChange?: (value: IVector3Like) => void;
            /**
                * Defines the optional callack called on the value finished changes.
                * @param value defines the new value of the object's property.
                */
            onFinishChange?: (value: IVector3Like) => void;
    }
    export interface IInspectorVector3State {
            /**
                * Defines the current value of the input.
                */
            value: IVector3Like;
    }
    export class InspectorVector3 extends React.Component<IInspectorVector3Props, IInspectorVector3State> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorVector3Props);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/notifier' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { _IDragAndDroppedItem } from "babylonjs-editor/renderer/editor/components/graph";
    import { AssetsBrowserItemHandler } from "babylonjs-editor/renderer/editor/components/assets-browser/files/item-handler";
    export interface IInspectorNotifierChangeOptions {
            /**
                * Defines the caller that notifies the change. This is typically used to don't listen themselves.
                */
            caller?: any;
            /**
                * Defines the optional time in milliseconds to wait before notifying changes.
                */
            waitMs?: number;
    }
    export class InspectorNotifier {
            /**
                * Notifies the inspectors that the given object has been notified.
                * @param object defines the reference to the object that has been changed.
                * @param caller defines the caller that notifies the change. This is typically used to don't listen themselves;
                */
            static NotifyChange<T>(object: T, options?: IInspectorNotifierChangeOptions): void;
            /**
                * Registers the given callback when the given object has been changed.
                * @param object defines the reference to the object to listen changes.
                * @param callback defines the callback called on the object has been changed and notified.
                * @returns the id of the nofifier. Should be kept in order to unregister.
                */
            static Register<T>(caller: any, object: T | (() => void), callback: () => void): number;
            /**
                * Unregisters the notifier identified by the given Id.
                * @param caller defines the reference to the original caller.
                */
            static Unregister(caller: any): void;
            static _DragAndDroppedGraphItem: Nullable<_IDragAndDroppedItem>;
            static _DragAndDroppedAssetItem: Nullable<AssetsBrowserItemHandler>;
            /**
                * Called on the user drops the asset in a supported inspector field.
                * @param ev defiens the reference to the event object.
                * @param object defines the reference to the object being modified in the inspector.
                * @param property defines the property of the object to assign the asset instance.
                */
            static NotifyOnDrop(ev: React.DragEvent<HTMLElement>, object: any, property: string): Promise<boolean>;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/color-picker' {
    import * as React from "react";
    import { Color3, Color4 } from "babylonjs";
    export interface IColor4Like {
            /**
                * Defines the red component (between 0 and 1, default is 0)
                */
            r: number;
            /**
                * Defines the green component (between 0 and 1, default is 0)
                */
            g: number;
            /**
                * Defines the blue component (between 0 and 1, default is 0)
                */
            b: number;
            /**
                * Defines the alpha component (between 0 and 1, default is 1)
                */
            a: number;
    }
    export interface IInspectorColorPickerProps {
            /**
                * Defines the reference to the object to modify.
                */
            object: any;
            /**
                * Defines the property to edit in the object.
                */
            property: string;
            /**
                * Defines the label of the field.
                */
            label: string;
            /**
                * Defines wether or not the label should be hidden.
                */
            noLabel?: boolean;
            /**
                * Defines wether or not automatic undo/redo should be skipped.
                */
            noUndoRedo?: boolean;
            /**
                * Defines the optional callback called on the value changes.
                * @param value defines the new value of the object's property.
                */
            onChange?: (value: Color3 | Color4) => void;
            /**
                * Defines the optional callack called on the value finished changes.
                * @param value defines the new value of the object's property.
                */
            onFinishChange?: (value: Color3 | Color4) => void;
    }
    export interface IInspectorColorPickerState {
            /**
                * Defines the current value of the input.
                */
            value: Color3 | Color4;
            /**
                * Defines the color in hexadecimal way.
                */
            hex: string;
            /**
                * Defines the color of the hex string.
                */
            textColor: string;
    }
    export class InspectorColorPicker extends React.Component<IInspectorColorPickerProps, IInspectorColorPickerState> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorColorPickerProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/list' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Suggest } from "@blueprintjs/select";
    import { MaybeElement } from "@blueprintjs/core";
    import { AbstractFieldComponent } from "babylonjs-editor/renderer/editor/gui/inspector/fields/abstract-field";
    export interface IInspectorListItem<T> {
            /**
                * Defines the label of the item.
                */
            label: string;
            /**
                * Defines the data attached to the item.
                */
            data: T;
            /**
                * Defines the optional description of the item (drawn on the right).
                */
            description?: string | React.ReactNode;
            /**
                * Defines the optional icon.
                */
            icon?: MaybeElement;
    }
    export interface IInspectorListProps<T> {
            /**
                * Defines the reference to the object to modify.
                */
            object: any;
            /**
                * Defines the property to edit in the object.
                */
            property: string;
            /**
                * Defines the label of the field.
                */
            label: string | JSX.Element;
            /**
                * Defines the list of items drawn in the suggest.
                */
            items: IInspectorListItem<T>[] | (() => IInspectorListItem<T>[] | Promise<IInspectorListItem<T>[]>);
            /**
                * Defines wether or not automatic undo/redo should be skipped.
                */
            noUndoRedo?: boolean;
            /**
                * Defines the optional list of all available drag'n'droppable types.
                */
            dndHandledTypes?: string[];
            /**
                * Defines the optional color to apply on the border left.
                */
            borderLeftColor?: string;
            /**
                * Defines the optional callback called on the value changes.
                * @param value defines the new value of the object's property.
                */
            onChange?: (value: T) => void;
            /**
                * Defines the optional callack called on the value finished changes.
                * @param value defines the new value of the object's property.
                * @param oldValue defines the old value of the property before it has been changed.
                */
            onFinishChange?: (value: T, oldValue: T) => void;
    }
    export interface IInspectorListState<T> {
            /**
                * Defines the list of all items available in the popover.
                */
            items: IInspectorListItem<T>[];
            /**
                * Defines the reference to the selected item.
                */
            selectedItem: Nullable<IInspectorListItem<T>>;
    }
    export class InspectorList<T> extends AbstractFieldComponent<IInspectorListProps<T>, IInspectorListState<T>> {
            /**
                * Defines the type of suggest used by the inspector list component.
                */
            static readonly ListSuggest: new (props: import("@blueprintjs/select").SuggestProps<IInspectorListItem<any>>) => Suggest<IInspectorListItem<any>>;
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IInspectorListProps<T>);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): Promise<void>;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/graph/node' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Scene } from "babylonjs";
    import { LGraphNode, LLink, SerializedLGraphNode, Vector2, LGraphCanvas, WidgetCallback, IWidget, INodeInputSlot, INodeOutputSlot } from "litegraph.js";
    declare module "babylonjs-editor/index//litegraph.js" {
            interface LGraphNode {
                    widgets?: IWidget[];
            }
    }
    export enum CodeGenerationOutputType {
            Constant = 0,
            Variable = 1,
            Function = 2,
            FunctionCall = 3,
            CallbackFunction = 4,
            Condition = 5,
            FunctionWithCallback = 6
    }
    export enum CodeGenerationExecutionType {
            Start = 0,
            Update = 1,
            Properties = 2
    }
    export enum ELinkErrorType {
            /**
                * Defines a link error raised when user wants to connect multiple nodes for an "EVENT".
                */
            MultipleEvent = 0
    }
    export interface ICodeGenerationOutput {
            /**
                * Defines the type of the output.
                */
            type: CodeGenerationOutputType;
            /**
                * Defines the generated code as string for the overall node.
                */
            code: string;
            /**
                * Defines the code generated for each output of the node.
                */
            outputsCode?: {
                    /**
                        * Defines the code generated by the output.
                        */
                    code?: string;
                    /**
                        * Defines wether or not the output is the name of the variable in "this".
                        */
                    thisVariable?: boolean;
            }[];
            /**
                * Defines where the execution should appear (onStart or onUpdate?).
                */
            executionType?: CodeGenerationExecutionType;
            /**
                * In case of a variable, this contains the name of the variable that is being generated an its value.
                */
            variable?: {
                    /**
                        * Defines the name of the variable.
                        */
                    name: string;
                    /**
                        * Defines the type of the variable.
                        */
                    type: string;
                    /**
                        * Defines the default value of the variable.
                        */
                    value: string;
                    /**
                        * Defines wether or not the variable is visibile in the inspector.
                        */
                    visibleInInspector?: boolean;
            };
            requires?: {
                    /**
                        * Defines the name of the module to require.
                        */
                    module: string;
                    /**
                        * Defines the classes the require from the module.
                        */
                    classes: string[];
            }[];
    }
    export interface INodeContextMenuOption {
            /**
                * Defines the label of the extra option in the context menu.
                */
            label: string;
            /**
                * Defines the callback caleld on the menu has been clicked.
                */
            onClick: () => void;
    }
    export abstract class GraphNode<TProperties = Record<string, any>> extends LGraphNode {
            /**
                * Defines all the available properties of the node.
                */
            properties: TProperties;
            /**
                * Defines wether or not a break point is set on the node.
                */
            hasBeakPoint: boolean;
            /**
                * Defines wether or not the node is paused on its breakpoint.
                */
            pausedOnBreakPoint: boolean;
            /**
                * Defines the id of the node to be used internally.
                */
            readonly internalId: string;
            /**
                * Defines the callback called on a widget changes.
                */
            onWidgetChange: Nullable<() => void>;
            /**
                * @hidden
                */
            _lastPosition: Vector2;
            /**
                * Constructor.
                * @param title defines the title of the node.
                */
            constructor(title?: string);
            /**
                * Returns the current scene where the graph is running.
                */
            getScene(): Scene;
            /**
                * Called on the graph is being started.
                */
            onStart(): void;
            /**
                * Called on the graph is being stopped.
                */
            onStop(): void;
            /**
                * Configures the node from an object containing the serialized infos.
                * @param infos defines the JSON representation of the node.
                */
            configure(infos: SerializedLGraphNode): void;
            /**
                * Retrieves the input data (data traveling through the connection) from one slot
                * @param slot defines the slot id to get its input data.
                * @param force_update defines wether or not to force the connected node of this slot to output data into this link
                */
            getInputData<T = any>(slot: number, force_update?: boolean): T;
            /**
                * On connections changed for this node, change its mode according to the new connections.
                * @param type input (1) or output (2).
                * @param slot the slot which has been modified.
                * @param added if the connection is newly added.
                * @param link the link object informations.
                * @param input the input object to check its type etc.
                */
            onConnectionsChange(type: number, _: number, added: boolean, link: LLink, input: any): void;
            /**
                * Called on a property changed.
                * @param name defines the name of the property that changed.
                * @param value defines the new value of the property.
                */
            propertyChanged(name: string, value: any): boolean;
            /**
                * Adds a new widget to the node.
                * @param type defines the type of widget.
                * @param name defines the name of the widget.
                * @param value defines the default value of the widget.
                * @param callback defines the callback called on the widget changed.
                * @param options defines the widget options.
                */
            addWidget<T extends IWidget>(type: T["type"], name: string, value: T["value"], callback?: WidgetCallback<T>, options?: T["options"]): T;
            /**
                * Adds a new input slot to use in this node
                * @param name defines the name of the input.
                * @param type string defining the input type ("vec3","number",...), it its a generic one use 0
                * @param extra_info this can be used to have special properties of an input (label, color, position, etc)
                */
            addInput(name: string, type: string | number, extra_info?: Partial<INodeInputSlot>): void;
            /**
                * Adds a new output slot to use in this node
                * @param name defines the name of the output.
                * @param type string defining the output type ("vec3","number",...)
                * @param extra_info this can be used to have special properties of an output (label, special color, position, etc)
                */
            addOutput(name: string, type: string | number, extra_info?: Partial<INodeOutputSlot>): void;
            /**
                * Triggers an slot event in this node.
                * @param slot the index of the output slot.
                * @param param defines the parameters to send to the target slot.
                * @param link_id in case you want to trigger and specific output link in a slot.
                */
            triggerSlot(slot: number, param?: any, link_id?: number): Promise<void>;
            /**
                * Called on the node is being executed.
                */
            onExecute(): Promise<void>;
            /**
                * In case of a breakpoint, resumes the graph.
                */
            resume(): void;
            /**
                * Sets the graph canvas to focus on this node.
                */
            focusOn(): void;
            /**
                * Called on the node is being executed.
                */
            abstract execute(): void | Promise<void>;
            /**
                * Generates the code of the node.
                * @param parent defines the parent node that has been generated.
                */
            abstract generateCode(...inputs: ICodeGenerationOutput[]): ICodeGenerationOutput;
            /**
                * Waits until the graph is resumed.
                */
            waitForBreakPoint(): Promise<void>;
            /**
                * Draws the foreground of the node.
                */
            onDrawForeground(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D): void;
            /**
                * Called each time the background is drawn.
                * @param ctx defines the rendering context of the canvas.
                */
            onDrawBackground(canvas: HTMLCanvasElement, _: CanvasRenderingContext2D): void;
            /**
                * Called each time the background is drawn.
                * @param ctx defines the rendering context of the canvas.
                */
            drawBackground(_: CanvasRenderingContext2D): void;
            /**
                * Called on the mouse is down on the node.
                * @param event defines the reference to the mouse original event.
                * @param pos defines the position.
                * @param graphCanvas defines the canvas where the node is drawn.
                */
            onMouseDown(event: MouseEvent, pos: Vector2, graphCanvas: LGraphCanvas): void;
            /**
                * Called on the mouse enters the node.
                * @param event defines the reference to the mouse original event.
                * @param pos defines the position.
                * @param graphCanvas defines the canvas where the node is drawn.
                */
            onMouseMove(_: MouseEvent, pos: Vector2, __: LGraphCanvas): void;
            /**
                * Called on the mouse enters the node.
                * @param event defines the reference to the mouse original event.
                * @param pos defines the position.
                * @param graphCanvas defines the canvas where the node is drawn.
                */
            onMouseEnter(event: MouseEvent, pos: Vector2, graphCanvas: LGraphCanvas): void;
            /**
                * Called on the mouse leaves the node.
                * @param event defines the reference to the mouse original event.
                * @param pos defines the position.
                * @param graphCanvas defines the canvas where the node is drawn.
                */
            onMouseLeave(event: MouseEvent, pos: Vector2, graphCanvas: LGraphCanvas): void;
            /**
                * Called on the node is right-clicked in the Graph Editor.
                * This is used to show extra options in the context menu.
                */
            getContextMenuOptions?(): INodeContextMenuOption[];
            /**
                * Returns the list of nodes connected to the given output.
                * @param outputId defines the Id of the output.
                */
            getConnectedNodesFromOutput(outputId: number): {
                    node: GraphNode;
                    inputId: number;
            }[];
            /**
                * Updates the given output's children nodes.
                * @param outputId defines the Id of the output that has been updated.
                */
            updateConnectedNodesFromOutput(outputId: number): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/project/files' {
    import { Nullable, IStringDictionary } from "babylonjs-editor/shared/types";
    export interface IFile {
            /**
                * The name of the file in file system.
                */
            name: string;
            /**
                * The absolute path of the file in the file system.
                */
            path: string;
    }
    export interface IContentFile extends IFile {
            /**
                * Defines the content of the file.
                */
            content: string;
    }
    export class FilesStore {
            /**
                * Defines the list of all available files in the project.
                */
            static List: IStringDictionary<IFile>;
            /**
                * Reference to the project's file.
                */
            static Project: Nullable<IFile>;
            /**
                * Clears the current file list of the project.
                */
            static Clear(): void;
            /**
                * Returns the number of files available in the project.
                */
            static GetFilesCount(): number;
            /**
                * Adds a new file to the files list according to the given file absolute path.
                */
            static AddFile(absolutePath: string): void;
            /**
                * Removes the file from the list, located at the given path.
                * @param path the path of the file to remove from the list.
                */
            static RemoveFileFromPath(path: string): void;
            /**
                * Returns the first file found which has the given path.
                * @param path the path of the file to find.
                */
            static GetFileFromPath(path: string): Nullable<IFile>;
            /**
                * Returns the key in the .list dictionary of the file located at the given path.
                * @param path the path of the file to find its key.
                */
            static GetKeyFromPath(path: string): Nullable<string>;
            /**
                * Returns the first file found which has the given base name.
                * @param name the name of the file to find.
                */
            static GetFileFromBaseName(name: string): Nullable<IFile>;
    }
}

declare module 'babylonjs-editor/renderer/editor/project/typings' {
    import { Undefinable, IStringDictionary } from "babylonjs-editor/shared/types";
    import { KTXToolsType } from "babylonjs-editor/renderer/editor/tools/ktx";
    import { IRegisteredPlugin } from "babylonjs-editor/renderer/editor/tools/types";
    import { ISerializedPostProcessAsset } from "babylonjs-editor/renderer/editor/scene/post-processes";
    /**
        * Defines the type the possible values of the physics engine type string
        * store in the workspace JSON file.
        */
    export type PhysicsEngineType = "cannon" | "oimo" | "ammo";
    /**
        * Defines the values of available package managers than can be used by
        * the editor for each workspace. The default value is "npm".
        */
    export type PackageManagerType = "npm" | "yarn";
    export interface IWorkSpace {
            /**
                * Defines the version of the Editor that handled the project.
                */
            editorVersion?: string;
            /**
                * Defines the local path to the latest opened project.
                */
            lastOpenedScene: string;
            /**
                * The port of the server used when testing the game.
                */
            serverPort: number;
            /**
                * Defines wether or not the final scene should be generated on the project is saved.
                */
            generateSceneOnSave: boolean;
            /**
                * Defines wether or not the project should be watched (webpack).
                */
            watchProject: boolean;
            /**
                * Defines wether or not the workspace has been loaded for the first time.
                */
            firstLoad: boolean;
            /**
                * Defines wether or not incremental loading is used when generating the final scenes.
                */
            useIncrementalLoading?: boolean;
            /**
                * Defines the physics engine that should be used by the project.
                */
            physicsEngine?: PhysicsEngineType;
            /**
                * Defines the dictionary that contains the preferences of external plugins in the editor.
                */
            pluginsPreferences?: Undefinable<IStringDictionary<any>>;
            /**
                * Defines the package manager used by the project.
                * Can be npm or yarn.
                */
            packageManager: PackageManagerType;
            /**
                * Defines the custom directory where to generate the output scenes. By default,
                * the value is the working directory of the workspace.
                * @default "./"
                */
            outputSceneDirectory: string;
            /**
                * Defines wether or not the project should be played in an isolated iFrame in the preview
                * panel when the user clicks the "play button". This is typically useful to avoid conflicts between
                * the version of Babylon.JS loaded in the editor and the one used in the project.
                */
            playProjectInIFrame?: boolean;
            /**
                * Defines the options set when the user wants to use HTTPS server.
                */
            https?: {
                    /**
                        * Defines wether or not HTTPS server is enabled.
                        */
                    enabled: boolean;
                    /**
                        * Defines the path to the certificate file.
                        */
                    certPath?: string;
                    /**
                        * Defines the path to the key file.
                        */
                    keyPath?: string;
            };
            /**
                * Defines the options of the custom webserver.
                */
            customWebServer?: {
                    /**
                        * Defines the Url of the custom webserver where to start the game.
                        */
                    url: string;
            };
            /**
                * Defines the options of the auto-lod feature.
                */
            autoLod?: {
                    /**
                        * Defines wether or not the auto-lod feature is enabled on scene is exported.
                        */
                    enabled?: boolean;
                    /**
                        * Defines wether or not the auto-lod is applied automatically once the scene is loaded.
                        */
                    autoApply?: boolean;
            };
            /**
                * Defines the options of the Basis compression tool.
                */
            basisCompressedTextures?: {
                    /**
                        * Defines wether or not Basis compressed texture is enabled using KTX Software.
                        */
                    enabled?: boolean;
            };
            /**
                * Defines the options of the KTX2 compression tool.
                */
            ktx2CompressedTextures?: {
                    /**
                        * Defines wether or not ktx2 compressed texture is enabled or not.
                        */
                    enabled?: boolean;
                    /**
                        * Defines the path to the PVRTexToolCLI program executed to generate all compressed textures files.
                        */
                    pvrTexToolCliPath?: string | Record<string, string>;
                    /**
                        * Defines the path to the NVidia Texture Tools program executed to generate DXT and ASTC files.
                        */
                    nvidiaTextureTools?: {
                            enabled?: boolean;
                            cliPath?: string;
                    };
                    /**
                        * Defines wether or not the Editor automatically generates compressed textures
                        * to be used in the Editor's preview scene.
                        */
                    enabledInPreview?: boolean;
                    /**
                        * Defines the optional format forced to be used when exporting the scene.
                        */
                    forcedFormat?: "automatic" | KTXToolsType;
                    /**
                        * Defines the options of the ASTC format.
                        */
                    astcOptions?: {
                            /**
                                * Defines the quality of the ASTC generated textures.
                                */
                            quality?: "astcveryfast" | "astcfast" | "astcmedium" | "astcthorough" | "astcexhaustive";
                    };
                    /**
                        * Defines the options of the PVRTC format.
                        */
                    pvrtcOptions?: {
                            /**
                                * Defines wether or not PVRTC is enabled.
                                */
                            enabled?: boolean;
                            /**
                                * Defines the quality of the PVRTC generated textures.
                                */
                            quality?: "pvrtcfastest" | "pvrtcfast" | "pvrtclow" | "pvrtcnormal" | "pvrtchigh" | "pvrtcveryhigh" | "pvrtcthorough" | "pvrtcbest";
                    };
                    /**
                        * Defines the options of the ETC1 format
                        */
                    ect1Options?: {
                            /**
                                * Defines wether or not ETC1 is enabled.
                                */
                            enabled?: boolean;
                            /**
                                * Defines the quality of the ETC1 generated textures.
                                */
                            quality: "etcfast" | "etcnormal" | "etcslow";
                    };
                    /**
                        * Defines the options of the ETC2 format
                        */
                    ect2Options?: {
                            /**
                                * Defines wether or not ETC2 is enabled.
                                */
                            enabled?: boolean;
                            /**
                                * Defines the quality of the ETC2 generated textures.
                                */
                            quality: "etcfast" | "etcnormal" | "etcslow";
                    };
            };
            /**
                * Defines the list of all registered plugins for the workspace.
                */
            plugins?: Undefinable<IRegisteredPlugin[]>;
    }
    export interface IProject {
            /**
                * Defines the list of the files associated to the project.
                */
            filesList?: string[];
            /**
                * Defines the list of scene's animation groups.
                */
            animationGroups: string[];
            /**
                * Defines the list of scene's cameras.
                */
            cameras: string[];
            /**
                * Defines the list of scene's textures.
                */
            textures: string[];
            /**
                * Defines the list of scene's materials.
                */
            materials: {
                    /**
                        * Defines the list of ids of meshes that have this material assigned.
                        */
                    bindedMeshes: string[];
                    /**
                        * Defines the JSON representation of the material.
                        */
                    json: string;
                    /**
                        * Defines wether or not the material is a multi material.
                        */
                    isMultiMaterial: boolean;
            }[];
            /**
                * Defines the list of scene's meshes.
                */
            meshes: string[];
            /**
                * Defines the list of scene's transform nodes.
                */
            transformNodes: string[];
            /**
                * Defines the list of scene's particle systems.
                */
            particleSystems?: {
                    /**
                        * Defines the id of the particle system.
                        */
                    id: string;
                    /**
                        * Defines the name of the particle system.
                        */
                    name: string;
                    /**
                        * Defines the path the JSON representation of the particle system.
                        */
                    json: string;
                    /**
                        * Defines the id of the emitter attached to the particle system.
                        */
                    emitterId?: string;
            }[];
            /**
                * Defines the list of scene's lights
                */
            lights: {
                    /**
                        * Defines the JSON representation of the light
                        */
                    json: string;
                    /**
                        * Defines the JSON representation of the shadow generator of the light.
                        */
                    shadowGenerator: Undefinable<string>;
            }[];
            /**
                * Defines the list of scene's sounds.
                */
            sounds?: string[];
            /**
                * Defines the list of all scene's morph target managers.
                */
            morphTargetManagers?: string[];
            /**
                * Defines the list of all reflection probes.
                */
            reflectionProbes?: string[];
            /**
                * Saves the scene's settings.
                */
            scene: any;
            /**
                * Defines all the informations about assets.
                */
            assets: {
                    /**
                        * Defines all the informations about the meshes assets.
                        */
                    meshes: string[];
                    /**
                        * Defines all the informations about the prefabs assets.
                        */
                    prefabs: Undefinable<string[]>;
                    /**
                        * Defines all the graphs available in the project.
                        */
                    graphs: Undefinable<string[]>;
            };
            /**
                * Defines the list of all project's cinematics.
                */
            cinematics: string[];
            /**
                * Defines some useful datas
                */
            project: {
                    /**
                        * Defines the current configuration of the editor camera.
                        */
                    camera: any;
            };
            /**
                * Defines the configurations of all post-processes.
                */
            postProcesses: {
                    /**
                        * Defines the list of all custom post-processes added by the user.
                        */
                    custom?: ISerializedPostProcessAsset[];
                    /**
                        * Defines the configuration of the SSAO.
                        */
                    ssao: {
                            /**
                                * Defines wether or not SSAO is enabled.
                                */
                            enabled: boolean;
                            /**
                                * Defines the JSON representation of the post-process
                                */
                            json: any;
                    };
                    ssr?: {
                            /**
                                * Defines wether or not the SSR pipeline is enabled.
                                */
                            enabled: boolean;
                            /**
                                * Defines the JSON representation of the post-process.
                                */
                            json: any;
                    };
                    /**
                        * Defines the configuration of the SSR post-process
                        */
                    screenSpaceReflections?: {
                            /**
                                * Defines wether or not SSR is enabled.
                                */
                            enabled: boolean;
                            /**
                                * Defines the JSON representation of the post-process
                                */
                            json: any;
                    };
                    /**
                        * Defines the configuration of the default pipeline.
                        */
                    default: {
                            /**
                                * Defines wether or not Default Pipeline is enabled.
                                */
                            enabled: boolean;
                            /**
                                * Defines the JSON representation of the post-process
                                */
                            json: any;
                    };
                    /**
                        * Defines the configuration of the motion blur post-process.
                        */
                    motionBlur?: {
                            /**
                                * Defines wether or not motion blur is enabled.
                                */
                            enabled: boolean;
                            /**
                                * Defines the JSON representation of the post-process
                                */
                            json: any;
                    };
            };
            /**
                * Defines wether or not the physics is enabled in the project.
                */
            physicsEnabled?: boolean;
    }
    /**
        * Defines partial typings of the .babylon file nodes.
        */
    export interface IBabylonFileNode {
            id: string;
            parentId: Undefinable<string>;
            metadata: any;
    }
    /**
        * Defines partial typings of the .babylon file.
        */
    export interface IBabylonFile {
            meshes: (IBabylonFileNode & {
                    geometryId?: string;
                    delayLoadingFile?: string;
                    boundingBoxMaximum?: number[];
                    boundingBoxMinimum?: number[];
                    _binaryInfo?: any;
                    materialId: Undefinable<string>;
                    instances: (IBabylonFileNode & {})[];
            })[];
            lights: (IBabylonFileNode & {})[];
            particleSystems: [];
            geometries?: {
                    vertexData?: {
                            id: string;
                    }[];
            };
    }
    export interface IAssetFileConfiguration {
            autoLod?: {
                    disabled?: boolean;
            };
            ktxCompression?: {
                    astc?: {
                            quality?: "none" | "automatic" | "astcveryfast" | "astcfast" | "astcmedium" | "astcthorough" | "astcexhaustive";
                    };
                    dxt?: {
                            type?: "none" | "automatic" | "BC1" | "BC2" | "BC3" | "BC4" | "BC5";
                    };
                    pvrtc?: {
                            quality?: "none" | "automatic" | "pvrtcfastest" | "pvrtcfast" | "pvrtclow" | "pvrtcnormal" | "pvrtchigh" | "pvrtcveryhigh" | "pvrtcthorough" | "pvrtcbest";
                    };
                    etc1?: {
                            quality?: "none" | "automatic" | "etcfast" | "etcnormal" | "etcslow";
                    };
                    etc2?: {
                            quality?: "none" | "automatic" | "etcfast" | "etcnormal" | "etcslow";
                    };
            };
    }
}

declare module 'babylonjs-editor/renderer/editor/project/project-exporter' {
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export class ProjectExporter {
            /**
                * Asks the user where to export the project and exports the project in the selected folder.
                * @param editor the editor reference.
                */
            static SaveAs(editor: Editor): Promise<void>;
            /**
                * Saves the project in the current location. If no path provided, a dialog will prompt to select
                * the folder where to export the project.
                * @param editor the editor reference.
                * @param skipGenerateScene defines wether or not the generation of the scene should be skipped.
                */
            static Save(editor: Editor, skipGenerateScene?: boolean): Promise<void>;
            /**
                * Returns the list of ALL exported files located in the scene's output folder.
                * @scenePath defines the absolute path to the .babylon file.
                * @filesPaths defines the list of all resource files of the scene.
                */
            static ListExportedFiles(): Promise<{
                    scenePath: string;
                    filesPaths: string[];
                    incrementalFiles: string[];
            }>;
            /**
                * Cleans the given output dir.
                */
            static _CleanOutputDir(directory: string, exportedFiles: string[]): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/project/project' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Cinematic } from "babylonjs-editor/renderer/editor/cinematic/cinematic";
    import { IProject } from "babylonjs-editor/renderer/editor/project/typings";
    export class Project {
            /**
                * Defines the path of the currently opened project.
                */
            static Path: Nullable<string>;
            /**
                * Defines the path to the directory containing the project.
                */
            static DirPath: Nullable<string>;
            /**
                * Defines the current project datas.
                */
            static Project: Nullable<IProject>;
            /**
                * Defines the list of all available cinematics for the project.
                */
            static Cinematics: Cinematic[];
            /**
                * Returns the project path set when opened the editor from the OS file system.
                */
            static GetOpeningProject(): Promise<Nullable<string>>;
            /**
                * Sets the new project path of the project.
                * @param path the new path of the project.
                */
            static SetOpeningProject(path: string): Promise<void>;
            /**
                * Opens the file dialog and loads the selected project.
                */
            static Browse(): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/project/workspace' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Terminal } from "xterm";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { IEditorProcess } from "babylonjs-editor/renderer/editor/tools/process";
    import { IWorkSpace } from "babylonjs-editor/renderer/editor/project/typings";
    export class WorkSpace {
            /**
                * Defines the absolute path of the workspace file.
                */
            static Path: Nullable<string>;
            /**
                * Defines the absolute path of the workspace folder.
                */
            static DirPath: Nullable<string>;
            /**
                * Defines the list of all available projects in the workspace.
                */
            static AvailableProjects: string[];
            /**
                * Defines the current project datas.
                */
            static Workspace: Nullable<IWorkSpace>;
            /**
                * Defines the port of the server used when testing the game.
                */
            static ServerPort: Nullable<number>;
            /**
                * Returns wether or not the editor has a workspace opened.
                */
            static HasWorkspace(): boolean;
            /**
                * Returns the workspace path set when opened the editor from the OS file system.
                */
            static GetOpeningWorkspace(): Promise<Nullable<string>>;
            /**
                * Sets the new project path of the project.
                * @param path the new path of the project.
                */
            static SetOpeningWorkspace(path: string): Promise<void>;
            /**
                * Reads the workspace file and configures the workspace class.
                * @param path the absolute path of the workspace file.
                */
            static ReadWorkSpaceFile(path: string): Promise<Nullable<IWorkSpace>>;
            /**
                * Writes the workspace file.
                * @param projectPath the absolute path of the saved project.
                */
            static WriteWorkspaceFile(projectPath: string): Promise<void>;
            /**
                * Returns the relative path to the directory where the output scene should be written.
                */
            static get OutputSceneDirectory(): string;
            /**
                * Refreshes the list of available projects in the workspace.
                */
            static RefreshAvailableProjects(): Promise<void>;
            /**
                * Returns the path of the latest opened project.
                */
            static GetProjectPath(): string;
            /**
                * Returns the name of the project.
                */
            static GetProjectName(): string;
            /**
                * Gets the reference to the webpack terminal.
                */
            static get WebpackTerminal(): Terminal;
            /**
                * Gets the reference to the TypeScript terminal.
                */
            static get TypeScriptTerminal(): Terminal;
            /**
                * Opens the file dialog and loads the selected project.
                */
            static Browse(): Promise<void>;
            /**
                * Closes the current workspace.
                */
            static Close(): Promise<void>;
            /**
                * Installs the workspace's dependencies.
                * @param editor defines the reference to the editor.
                * @returns the promise resolved on the dependencies have been installed.
                */
            static InstallDependencies(editor: Editor): Promise<void>;
            /**
                * Installs and builds the project.
                * @param editor the editor reference.
                */
            static InstallAndBuild(editor: Editor): Promise<void>;
            /**
                * Builds the project.
                * @param editor the editor reference.
                */
            static BuildProject(editor: Editor): Promise<void>;
            /**
                * Watchs the project using webpack.
                * @param editor the editor reference.
                */
            static WatchProject(editor: Editor): Promise<void>;
            /**
                * Returns wether or not the project is being watched using webpack.
                */
            static get IsWatchingProject(): boolean;
            /**
                * Stops watching the project using webpack.
                */
            static StopWatchingProject(): void;
            /**
                * Watchs the project's typescript using tsc. This is used to safely watch attached scripts on nodes.
                * @param editor the editor reference.
                */
            static WatchTypeScript(editor: Editor): Promise<Nullable<IEditorProcess>>;
            /**
                * Compiles the project's typescript using tsc.
                * @param editor defines the reference to the editor.s
                * @param watch defines wether or not the TypeScript code should be watched.
                */
            static CompileTypeScript(editor: Editor, watch?: boolean): Promise<Nullable<IEditorProcess>>;
            /**
                * Returns wether or not the typescript project is being watched.
                */
            static get IsWatchingTypeScript(): boolean;
            /**
                * Stops watching the TypeScript project.
                */
            static StopWatchingTypeScript(): void;
            /**
                * Restarts the TypeScript watcher in case it goes in error.
                * @param editor defines the editor reference.
                */
            static RestartTypeScriptWatcher(editor: Editor): Nullable<IEditorProcess>;
            /**
                * Returns wether or not the major Babylon.JS version of the project matches with the one of the editor.
                * Checked at initialization time of the Editor.
                * @param version defines the version of Babylon.JS being used by the editor.
                */
            static MatchesEditorBabylonJSMajorVersion(version: string): Promise<boolean>;
            /**
                * Configures the package.json file of the project to match the Babylon.JS version used in the editor.
                * Checked at initialization time of the Editor.
                * @param version defines the version of Babylon.JS being used by the editor.
                */
            static MatchBabylonJSEditorVersion(version: string): Promise<void>;
            /**
                * Kills all the existing programs.
                */
            static KillAllProcesses(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/project/scene-exporter' {
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface IExportFinalSceneOptions {
            /**
                * defines the optional path where to save to final scene.
                */
            destPath?: string;
            /**
                * Defines the root path applied on geometries in .babylon file in case of incremental loading.
                */
            geometryRootPath?: string;
            /**
                * Defines wether or not files are forced to be re-generated.
                */
            forceRegenerateFiles?: boolean;
            /**
                * Defines wether or not all compressed textures should be regenerated.
                */
            forceRegenerateCompressedTextures?: boolean;
            /**
                * Defines wether or not all compressed texture formats should be generated.
                * Typically used when exporting final scene version.
                */
            generateAllCompressedTextureFormats?: boolean;
            /**
                * Defines wether or not the automatic lod generation for textures should
                * be bypassed. Typically set to true when playing in the editor.
                */
            byPassAutoLodGeneration?: boolean;
    }
    export class SceneExporter {
            /**
                * Defines the list of all textures file types that are copy-able for the
                * final assets output folder.
                */
            static readonly CopyAbleImageTypes: string[];
            /**
                * Defines the list of all video file types that are copy-able for the
                * final assets output folder.
                */
            static readonly CopyAbleVideoTypes: string[];
            /**
                * Defines the list of all 3d assets file types that are copy-able for the
                * final assets output folder.
                */
            static readonly CopyAble3dAssetTypes: string[];
            /**
                * Defines the list of all file types that are copy-able for the
                * final assets output folder.
                */
            static readonly CopyAbleAssetsTypes: string[];
            /**
                * Exports the final scene and asks for the destination folder.
                * @param editor defines the reference to the editor.
                */
            static ExportFinalSceneAs(editor: Editor): Promise<void>;
            /**
                * Eports the final scene.
                * @param editor the editor reference.
                * @param task defines the already existing task feedback to reuse.
                * @param destPath defines the optional path where to save to final scene.
                */
            static ExportFinalScene(editor: Editor, task?: string, options?: IExportFinalSceneOptions): Promise<void>;
            /**
                * Exports the current scene into .babylon format including only geometries.
                * @param editor defines the reference to the editor.
                */
            static ExportFinalSceneOnlyGeometries(editor: Editor): Promise<void>;
            /**
                * Returns the final scene in its JSON representation.
                * @param editor defines the reference to the editor.
                */
            static GetFinalSceneJson(editor: Editor): any;
            /**
                * Returns the location of the exported scene on the file system.
                */
            static GetExportedSceneLocation(): string;
            /**
                * Generates the scripts for the project. Will wirte the "tools.ts" file and all index.ts files.
                * @param editor defines the reference to the editor.
                */
            static GenerateScripts(editor: Editor): Promise<void>;
            /**
                * Copies the shader files located in the "src" folder to the output src folder of the typescript build.
                * Typescript build folder is located in the "build" folder of the workspace. This is mainly used to allow
                * testing the game in the editor as shader files are required using "require" and transformed to raw by webpack
                * for the web version.
                * @param editor defines the reference to the editor.
                */
            static CopyShaderFiles(editor: Editor): Promise<void>;
            /**
                * Copies the current project configuration as a Json file.
                * @param editor defines the editor reference.
                */
            static GetProjectConfiguration(editor: Editor): any;
            /**
                * Exports all available graphs in the scene.
                * @param editor defines the reference to the editor.
                */
            static ExportGraphs(editor: Editor): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/export/mesh' {
    import { Mesh } from "babylonjs";
    export class MeshExporter {
        /**
          * Exports the given mesh to its JSON representation.
          * @param mesh defines the reference to the mesh to export.
          * @param withParents defines if parents must be serialized as well with the mesh.
          * @param withChildren defines if children must be serialized as well with the mesh.
          * @returns the reference to the JSON representation of the given mesh.
          */
        static ExportMesh(mesh: Mesh, withParents?: boolean, withChildren?: boolean): any;
    }
}

declare module 'babylonjs-editor/renderer/editor/export/geometry' {
    import { IBabylonFile } from "babylonjs-editor/renderer/editor/project/typings";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export class GeometryExporter {
            /**
                * Initializes the geometry exporter.
                */
            static Init(): Promise<void>;
            /**
                * Exports all the geometries of the given serialized scene to their incremental form.
                * @param editor defines the reference to the editor.
                * @param path defines the absolute path where to export all the geometries of the given scene.
                * @param scene defines the reference to the serialized scene to export its geometries.
                * @param finalExport defines wether or not this export is the final export (generating scene or saving project?).
                * @param overridePath defines the optional path to set before the "geometries/" folder.
                * @param task defines the reference to the optional task used to notify feedbacks to the user about export progress.
                * @returns the list of all geometry files that have been created.
                */
            static ExportIncrementalGeometries(editor: Editor, path: string, scene: IBabylonFile, finalExport: boolean, overridePath?: string, task?: string): Promise<string[]>;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/alert' {
    import * as React from "react";
    import { IconName, MaybeElement } from "@blueprintjs/core";
    import { Undefinable } from "babylonjs-editor/shared/types";
    export interface IAlertOptions {
            /**
                * Defines whether clicking outside the overlay element (either on backdrop when present or on document)
                * should invoke `onClose`.
                */
            canOutsideClickClose?: boolean;
            /**
                * Defines whether to show the close button in the dialog's header.
                * Note that the header will only be rendered if `title` is provided.
                */
            isCloseButtonShown?: boolean;
            /**
                * Defines wehter or not footer should be shown.
                */
            noFooter?: boolean;
            /**
                * Defines the optional style of the alert.
                */
            style?: React.CSSProperties;
    }
    export interface IAlertProps extends IAlertOptions {
            /**
                * The title of the dialog.
                */
            title: string;
            /**
                * The message of the dialog.
                */
            message: string;
            /**
                * The icon to show on top-left of the dialog.
                */
            icon: Undefinable<IconName | MaybeElement>;
            /**
                * Defines the html div element that contains the alert.
                */
            container: HTMLDivElement;
            /**
                * Optional body element.
                */
            body?: Undefinable<JSX.Element>;
            /**
                * Called on the alert is closed.
                */
            onClose: () => void;
    }
    export class Alert extends React.Component<IAlertProps, {}> {
            /**
                * Shows the dialog with a title and a message.
                * @param title the title of the dialog.
                * @param message the message of the dialog.
                * @param icon the icon of the dialog to show on top-left.
                * @param body optional body to draw in the alert.
                */
            static Show(title: string, message: string, icon?: Undefinable<IconName | MaybeElement>, body?: Undefinable<JSX.Element>, options?: IAlertOptions, ref?: (ref: Alert) => void): Promise<void>;
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IAlertProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the user clicks on the "Ok" button or closes the dialog.
                */
            close(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/dialog' {
    import { Undefinable, Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    export interface IDialogProps {
            /**
                * The title to draw in the dialog
                */
            title: string;
            /**
                * The message to show in the dialog.
                */
            message: string;
            /**
                * The icon to show on top-left of the dialog.
                */
            icon: Undefinable<JSX.Element>;
            /**
                * Defines the html div element that contains the alert.
                */
            container: HTMLDivElement;
            /**
                * Defines wether or not the input should be a password.
                */
            password: Undefinable<boolean>;
            /**
                * Optional body element.
                */
            body?: Undefinable<JSX.Element>;
            /**
                * Called on the alert is closed.
                */
            onClose: (value: Nullable<string>) => void;
    }
    export class Dialog extends React.Component<IDialogProps> {
            /**
                * Shows the dialog with a title and a message.
                * @param title the title of the dialog.
                * @param message the message of the dialog.
                * @param icon the icon of the dialog to show on top-left.
                * @param password defines wether or not the input should be a password.
                */
            static Show(title: string, message: string, icon?: Undefinable<JSX.Element>, password?: boolean): Promise<string>;
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/confirm' {
    import * as React from "react";
    import { IconName } from "@blueprintjs/core";
    import { Undefinable } from "babylonjs-editor/shared/types";
    export interface IConfirmProps {
            /**
                * The title of the dialog.
                */
            title: React.ReactNode;
            /**
                * The message of the dialog.
                */
            message: React.ReactNode;
            /**
                * The icon to show on top-left of the dialog.
                */
            icon: Undefinable<IconName | JSX.Element>;
            /**
                * Defines the html div element that contains the alert.
                */
            container: HTMLDivElement;
            /**
                * Called on the user clicks on "Yes" or "No".
                */
            onAnswer: (yes: boolean) => void;
    }
    export class Confirm extends React.Component<IConfirmProps> {
            /**
                * Shows the dialog.
                * @param title the title of the dialog.
                * @param message the message of the dialog.
                * @param icon the icon of the dialog to show on top-left.
                */
            static Show(title: React.ReactNode, message: React.ReactNode, icon?: Undefinable<IconName | JSX.Element>): Promise<boolean>;
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/icon' {
    import * as React from "react";
    import { Undefinable } from "babylonjs-editor/shared/types";
    export interface IIconProps {
            /**
                * The source of the image. Can be a svg.
                */
            src: string;
            /**
                * Optional id to set to the img element.
                */
            id?: Undefinable<string>;
            /**
                * Optional style to pass to the img element.
                */
            style?: Undefinable<React.CSSProperties>;
            /**
                * Optional callback called on the user clicks on the icon.
                */
            onClick?: Undefinable<(event: React.MouseEvent<HTMLImageElement, MouseEvent>) => void>;
            /**
                * Optional callback called ont he user's mouse is over the icon.
                */
            onOver?: Undefinable<(event: React.MouseEvent<HTMLImageElement, MouseEvent>) => void>;
            /**
                * Optional callback called ont he user's mouse left the icon.
                */
            onLeave?: Undefinable<(event: React.MouseEvent<HTMLImageElement, MouseEvent>) => void>;
    }
    export interface IIconState {
            /**
                * Style to pass/update to the img element.
                */
            style: React.CSSProperties;
    }
    /**
        * Defines the icon
        */
    export class Icon extends React.Component<IIconProps, IIconState> {
            /**
                * Constructor.
                */
            constructor(props: IIconProps);
            /**
                * Renders the icon component.
                */
            render(): React.ReactNode;
    }
}

declare module 'babylonjs-editor/renderer/editor/scene/import-tools' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { IParticleSystem, ISceneLoaderAsyncResult, Material, Node, Scene, Skeleton, TransformNode } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface ISceneImporterToolsConfiguration {
            /**
                * Defines the reference to the editor.
                */
            editor: Editor;
            /**
                * Defines wether or not the scene to configure its nodes are coming from a GLTF file.
                */
            isGltf: boolean;
            /**
                * Defines the relative path (from workspace) to the scene's file.
                */
            relativePath: string;
            /**
                * Defines the absolute path to the scene's file.
                */
            absolutePath: string;
            /**
                * Defines the result of the scene loader containing the meshes, skeletons etc.
                */
            result: ISceneLoaderAsyncResult;
    }
    export class SceneImporterTools {
            /**
                * Configures the given scene loader result contained in the given scene (id, material files etc.).
                * @param scene defines the reference to the scene containing the elements to configure.
                * @param configuration defines the configuration containing the information for the elements to configure.
                */
            static Configure(scene: Scene, configuration: ISceneImporterToolsConfiguration): Promise<Node>;
            /**
                * Configures the given imported particle systems.
                */
            static ConfigureParticleSystems(particleSystems: IParticleSystem[]): void;
            /**
                * Configures the given imported skeletons.
                */
            static ConfigureSkeletons(skeletons: Skeleton[], scene: Scene): void;
            /**
                * Configures the given imported transform nodes.
                */
            static ConfigureTransformNodes(transformNodes: TransformNode[], parent: Nullable<TransformNode>): void;
            /**
                * Configures the given imported transform nodes.
                */
            static ConfigureMeshes(configuration: ISceneImporterToolsConfiguration, parent: TransformNode): Promise<void>;
            /**
                * Configures the given imported material.
                */
            static ConfigureMaterial(material: Material, configuration: ISceneImporterToolsConfiguration, force?: boolean): Promise<Material>;
    }
}

declare module 'babylonjs-editor/renderer/editor/project/packer/packer' {
    import { DirectoryTree } from "directory-tree";
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Observable } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface IPackerOptions {
            /**
                * Defines the list of all absolute paths to files to pack.
                */
            files: string[];
            /**
                * Defines wether or not the build process should be skipped.
                */
            skipBuild?: boolean;
    }
    export enum PackerStatus {
            /**
                * Defines the status where the project is being built.
                */
            Building = 0,
            /**
                * Defines the status where the zip file is being populated.
                */
            Packing = 1,
            /**
                * Defines the status where the zip file buffer is being generated.
                */
            GeneratingBuffer = 2,
            /**
                * Defines the status where the packer has finished.
                */
            Done = 3,
            /**
                * Defines the statis wehre the packer raised an error.
                */
            Error = 4
    }
    export class Packer {
            /**
                * Defines the observable used to notify observers that a package buffer has been generated.
                * This buffer can be used by plugins to upload the buffer itself on a webserver and so on.
                */
            static OnGeneratedPackageBuffer: Observable<Buffer>;
            /**
                * Defines the observable used to nofity observers that a new entry has been added to the archive.
                */
            onAddEntry: Observable<string>;
            /**
                * Defines the observable used to notify observers that the packer status changed.
                */
            onStatusChange: Observable<PackerStatus>;
            /**
                * Constructor.
                * @param editor defines the reference to the editor.
                */
            constructor(editor: Editor);
            /**
                * Returns the list of all root directory trees from the given files list to pack.
                * @param files defines the list of all files to pack.
                */
            getRootDirectories(files: string[]): DirectoryTree[];
            /**
                * Builds the project.
                */
            build(): Promise<void>;
            /**
                * Packs the project.
                * @param options defines the options of the packer.
                */
            pack(options: IPackerOptions): Promise<Nullable<Buffer>>;
            /**
                * Packs and writes the zip file to the given destination file.
                * @param destination defines the destination file where to write the zip file.
                * @param options defines the options of the packer.
                */
            packToFile(destination: string, options: IPackerOptions): Promise<void>;
    }
}

declare module 'babylonjs-editor/shared/types' {
    /**
        * Defines a string dictionary.
        */
    export interface IStringDictionary<T> {
            [index: string]: T;
    }
    /**
        * Defines a number dictionary.
        */
    export interface INumberDictionary<T> {
            [index: number]: T;
    }
    /**
        * Defines a member that can have a value or be null.
        */
    export type Nullable<T> = null | T;
    /**
        * Defines a member that can have a value or be undefined.
        */
    export type Undefinable<T> = undefined | T;
}

declare module 'babylonjs-editor/renderer/editor/tools/types' {
    import { Undefinable, IStringDictionary, Nullable } from "babylonjs-editor/shared/types";
    import { Material, Geometry, Skeleton, SubMesh, Mesh } from "babylonjs";
    export interface IObjectModified<T> {
            /**
                * Defines the reference to the object that has been modified.
                */
            object: T;
            /**
                * Defines the path as a string of the modified property.
                * @example "position.x"
                * @example "name"
                */
            path: string;
    }
    export interface IEditorPreferences {
            /**
                * Defines the path of the terminal to execute when opening the terminal in the editor.
                */
            terminalPath?: string;
            /**
                * Defines the current zoom value of the editor.
                */
            zoom?: string;
            /**
                * Defines the current hardware scaling level.
                */
            scalingLevel?: number;
            /**
                * Defines the list of all position snapping values.
                */
            positionGizmoSnapping?: number[];
            /**
                * Defines wether or not an overlay should be drawn on the user puts his mouse
                * over an element in the preview.
                */
            noOverlayOnDrawElement?: boolean;
            /**
                * Defines the list of all registered plugins for the editor.
                */
            plugins?: Undefinable<IRegisteredPlugin[]>;
            /**
                * Defines wether or not the developer mode is activated. When activated, the editor will install
                * the React dev tools and other dev tools useful to debug plugins.
                */
            developerMode?: Undefinable<boolean>;
    }
    export interface IRegisteredPlugin {
            /**
                * Defines the name of the plugin.
                */
            name: string;
            /**
                * Defines the path to the plugin.
                */
            path: string;
            /**
                * Defines wether or not the plugin is enabled.
                */
            enabled: boolean;
            /**
                * Defines wether or not the plugin comes from NPM.
                */
            fromNpm?: boolean;
    }
    export enum EditorPlayMode {
            /**
                * Opens the game in a new panel of the Editor.
                */
            EditorPanelBrowser = 0,
            /**
                * Opens the game in a new window using the integrated browser.
                */
            IntegratedBrowser = 1,
            /**
                * Opens the game in an external browser (see user's prefs).
                */
            ExternalBrowser = 2
    }
    export interface IAttachedScriptMetadata {
            /**
                * Defines the name of the script.
                */
            name?: string;
            /**
                * Defines the dictionary of all editable properties.
                */
            properties?: IStringDictionary<{
                    type: string;
                    value?: number | boolean | string | {
                            x: number;
                            y: number;
                            z?: number;
                            w?: number;
                    } | {
                            r: number;
                            g: number;
                            b: number;
                            a?: number;
                    };
            }>;
    }
    export interface IOriginalSourceFileMetadata {
            /**
                * Defines the id of the mesh in the scene file.
                */
            id: string;
            /**
                * Defines the name of the mesh in the scene file.
                */
            name: string;
            /**
                * Defines the name of the scene file.
                */
            sceneFileName: string;
    }
    export interface ICommonMetadata {
            /**
                * Defines wether or not the mesh is pickable.
                */
            isPickable?: boolean;
            /**
                * Defines wether or not the node is exportable.
                */
            doNotExport?: boolean;
            /**
                * Defines wether or not the mesh is locked.
                */
            isLocked?: boolean;
            /**
                * Defines the overall script properties of the object (scene or node).
                */
            script?: IAttachedScriptMetadata;
            /**
                * Defines the optional CSS properties for custom rendering in editor's graph.
                */
            editorGraphStyles?: React.CSSProperties;
            /**
                * Any other key
                */
            [index: string]: any;
    }
    export interface IMeshMetadata extends ICommonMetadata {
            /**
                * In case the mesh is exported as binary format, this defines wether or not
                * the geometry for THIS mesh should be kept inline.
                */
            keepGeometryInline?: boolean;
            /**
                * Defines the original data of the source file.
                */
            originalSourceFile?: IOriginalSourceFileMetadata;
            heightMap?: {
                    /**
                        * Defines the buffer of the height map texture.
                        */
                    texture: number[];
                    /**
                        * Defines the width of the texture.
                        */
                    textureWidth: number;
                    /**
                        * Defines the height of the texture.
                        */
                    textureHeight: number;
                    /**
                        * Defines the options of the heightmap when being applied.
                        * @see VertexData.CreateGroundFromHeightMap for more information.
                        */
                    options: {
                            minHeight: number;
                            maxHeight: number;
                            colorFilter: number[];
                    };
            };
            /**
                * Defines the objects that are waiting to be updated.
                */
            _waitingUpdatedReferences?: {
                    /**
                        * Defines the geometry object containing the components to update.
                        */
                    geometry?: {
                            /**
                                * Defines the updated geometry reference.
                                */
                            geometry: Nullable<Geometry>;
                            /**
                                * Defines the updated skeleton reference.
                                */
                            skeleton: Nullable<Skeleton>;
                            /**
                                * Defines the list of new sub-meshes.
                                */
                            subMeshes: SubMesh[];
                            /**
                                * Defines the handler to call in order to apply the updated material reference.
                                */
                            handler?: (mesh: Mesh, withSkeleton: boolean) => unknown | Promise<unknown>;
                    };
                    /**
                        * Defines the material object containing the component's to update.
                        */
                    material?: {
                            /**
                                * Defines wether or not the material comes from a gltf mesh file.
                                */
                            isGltf: boolean;
                            /**
                                * Defines the reference to the material to update.
                                */
                            material: Nullable<Material>;
                            /**
                                * Defines the handler to call in order to apply the updated material reference.
                                */
                            handler?: (mesh: Mesh) => unknown | Promise<unknown>;
                    };
            };
    }
    export interface ITransformNodeMetadata extends ICommonMetadata {
            /**
                * Defines the original data of the source file.
                */
            originalSourceFile?: IOriginalSourceFileMetadata;
    }
    export interface IGroundMetadata {
            /**
                * Defines the options available when the ground is associated to a height map.
                */
            heightMap?: {
                    /**
                        * Defines the buffer used to store the texture's pixels.
                        */
                    texture?: number[];
                    /**
                        * Defines the width of the texture.
                        */
                    textureWidth?: number;
                    /**
                        * Defines the height of the texture.
                        */
                    textureHeight?: number;
                    /**
                        * Defines the options passed to the height map generator of Babylon.JS.
                        */
                    options?: {
                            /**
                                * Defines the minimum height applied on the height map.
                                */
                            minHeight: number;
                            /**
                                * Defines the maximum height applied on the height map.
                                */
                            maxHeight: number;
                            /**
                                * Defines the color filter applied on the height map.
                                */
                            colorFilter: number[];
                    };
            };
    }
    export interface IMaterialMetadata {
            /**
                * Defines the relative path in the project of the material asset.
                */
            editorPath?: string;
            /**
                * Defines the original data of the source file.
                */
            originalSourceFile?: IOriginalSourceFileMetadata;
    }
}

declare module 'babylonjs-editor/renderer/editor/scene/utils' {
    import { Scene } from "babylonjs";
    import { IExportedInspectorValue } from "babylonjs-editor/renderer/sandbox/main";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface INodeResult {
            /**
                * Defines the Id of the node.
                */
            id: string;
            /**
                * Defines the name of the node.
                */
            name: string;
    }
    export interface IMeshResult extends INodeResult {
            /**
                * Defines the type of the mesh.
                */
            type: string;
    }
    export interface ICameraResult extends INodeResult {
            /**
                * Defines the type of the mesh.
                */
            type: string;
    }
    export interface ILightResult extends INodeResult {
            /**
                * Defines the type of the mesh.
                */
            type: string;
    }
    export interface IAssetResult {
            /**
                * Defines the name drawn in the editor.
                */
            name: string;
            /**
                * Defines the base64 value of the texture.
                */
            base64: string;
    }
    export interface IMaterialResult extends IAssetResult {
            /**
                * Defines the type of material.
                */
            type: string;
    }
    export interface ISceneJsonResult {
            /**
                * Defines the JSON representation of the scenE.
                */
            scene: any;
            /**
                * Defines the Root Url of the scene.
                */
            rootUrl: string;
            /**
                * Defines the name of the scene (project).
                */
            sceneName: string;
            /**
                * Defines the absolute path to the workspace.
                */
            workspacePath: string;
    }
    export interface ISerializablePropertyResult {
            /**
                * Defines the type of the property.
                */
            type: string;
            /**
                * Defines the name of the property.
                */
            propertyKey: string;
    }
    export class SceneUtils {
            /**
                * Defines the current scene.
                */
            readonly scene: Scene;
            /**
                * Constructor.
                * @param scene defines the scene reference.
                */
            constructor(editor: Editor);
            /**
                * Returns the list of all available nodes in the scene.
                */
            getAllNodes(): INodeResult[];
            /**
                * Returns the list of all meshes.
                */
            getAllMeshes(): IMeshResult[];
            /**
                * Returns the list of all lights.
                */
            getAllLights(): ILightResult[];
            /**
                * Returns the list of all cameras.
                */
            getAllCameras(): ICameraResult[];
            /**
                * Returns the list of all transform nodes.
                */
            getAllTransformNodes(): INodeResult[];
            /**
                * Returns the list of all particle systems.
                */
            getAllParticleSystems(): INodeResult[];
            /**
                * Returns the list of all sounds in the scene.
                */
            getAllSounds(): string[];
            /**
                * Returns the list of all animation groups in the scene.
                */
            getAllAnimationGroups(): string[];
            /**
                * Returns the list of all skeletons.
                */
            getAllSkeletons(): INodeResult[];
            /**
                * Returns the list of all textures in the scene.
                */
            getAllTextures(): IAssetResult[];
            /**
                * Returns the list of all textures in the scene.
                */
            getAllMaterials(): IMaterialResult[];
            /**
                * Returns the list of all serializable properties from attached script(s) of the node idenfified
                * by the given Id.
                * @param id defines the id of the node to gets its serializable properties from attached script(s).
                */
            getNodeScriptSerializableProperties(id: string): Promise<IExportedInspectorValue[]>;
            /**
                * Returns the final scene in its JSON representation.
                */
            getSceneJson(): ISceneJsonResult;
    }
}

declare module 'babylonjs-editor/renderer/editor/scene/post-processes' {
    import { PostProcess } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface IPostProcessAsset {
            /**
                * Defines the relative path to the post-process source code.
                */
            sourcePath: string;
            /**
                * Defines the reference to the post-process.
                */
            postProcess: PostProcess;
    }
    export interface ISerializedPostProcessAsset {
            /**
                * Defines the relative path to the post-process source code.
                */
            sourcePath: string;
            /**
                * Defines the reference to the JSON representation of the post-process.
                */
            serializationObject: any;
    }
    export class PostProcessAssets {
            /**
                * Returns wether or not the given post-process in a reserved one.
                * @param p defines the reference to the post-process to test.
                */
            static IsReservedPostProcess(p: PostProcess): boolean;
            /**
                * Defines the list of all available post-processes.
                */
            postProcesses: IPostProcessAsset[];
            /**
                * Constructor.
                * @param editor defines the reference to the editor.
                */
            constructor(editor: Editor);
            /**
                * Adds the given post-process to the list of available custom post-processes in the project.
                * @param sourcePath defines the relative path to the source file of the post-process.
                * @param postProcess defines the reference to the created post-process.
                */
            addPostProcess(sourcePath: string, postProcess: PostProcess): void;
            /**
                * Resets all the processes related to the post-processes such as the watchers etc.
                */
            reset(): void;
            /**
                * Serializes all the post-processes.
                */
            serialize(): ISerializedPostProcessAsset[];
    }
}

declare module 'babylonjs-editor/renderer/editor/components/graph' {
    import * as React from "react";
    import { TreeNodeInfo } from "@blueprintjs/core";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface _IDragAndDroppedItem {
            nodeId: string;
            onDropInInspector: (ev: React.DragEvent<HTMLElement>, object: any, property: string) => Promise<void>;
    }
    export interface IGraphProps {
            /**
                * Defines the reference to the editor.
                */
            editor: Editor;
    }
    export interface IGraphState {
            /**
                * Defines the current string of the filter box.
                */
            filter: string;
            /**
                * Defines the list of all nodes drawn in the graph.
                */
            nodes: TreeNodeInfo<any>[];
            /**
                * Defines the list of all selected nodes in the graph.
                */
            selectedNodes: TreeNodeInfo<any>[];
    }
    export class Graph extends React.Component<IGraphProps, IGraphState> {
            /**
                * Defines the reference to the last selected object.
                */
            lastSelectedObject: any;
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IGraphProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Removes the given object from the scene graph.
                * @param node defines the reference to the object to remove.
                */
            removeObject(node: any): void;
            /**
                * Resizes the component.
                */
            resize(): void;
            /**
                * Called on the user clicks on a node.
                */
            _handleNodeClick(node: TreeNodeInfo<any>, event: React.MouseEvent<HTMLElement, MouseEvent>): void;
            /**
                * Refreshes the entire graph.
                * @param done defines the reference to the callback called on the graph has been updated.
                */
            refresh(done?: () => void): void;
            /**
                * Updates the current graph state without parsing the scene nodes.
                */
            update(): void;
            /**
                * Sets the given object selected in the graph.
                * @param object defines the reference to the object to set selected in the graph.
                * @param appendToSelected defines wether or not the object should be added to the currently selected node(s) in the graph.
                */
            setSelected(object: any, appendToSelected?: boolean): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/assets-browser' {
    import { IStringDictionary, Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { AssetsBrowserTree } from "babylonjs-editor/renderer/editor/components/assets-browser/tree";
    import { AssetsBrowserFiles } from "babylonjs-editor/renderer/editor/components/assets-browser/files";
    export interface IAssetsBrowserProps {
            /**
                * Defines the reference to the editor.
                */
            editor: Editor;
    }
    export interface IAssetsBrowserState {
            /**
                * Defines width in pixels of the pane.
                */
            paneWidth: number;
            /**
                * Defines the current absolute path being browsed.
                */
            browsedPath: string;
    }
    export class AssetsBrowser extends React.Component<IAssetsBrowserProps, IAssetsBrowserState> {
            /**
                * Initializes the assets browser. Will typically create the "assets" folder
                * located in the root directory of the loaded workspace.
                * @param editor defines the reference to the editor.
                */
            static Init(editor: Editor): Promise<void>;
            /**
                * Defines the absolute path to the assets directory.
                */
            assetsDirectory: string;
            /**
                * Defines the reference to the dictionary that stores all the moved assets.
                */
            movedAssetsDictionary: IStringDictionary<string>;
            /**
                * @hidden
                */
            _tree: Nullable<AssetsBrowserTree>;
            /**
                * @hidden
                */
            _files: Nullable<AssetsBrowserFiles>;
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IAssetsBrowserProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Sets the workspace directory absolute path and refreshes the component.
                * @param workspacePath defines the absolute path to the workspace directory.
                */
            setWorkspaceDirectoryPath(workspacePath: string): void;
            /**
                * Reveals the assets-browser panel in the layout, shows the directory of the given file and makes the file selected.
                * @param relativePath defines the path of the file to show relative to the assets directory.
                */
            revealPanelAndShowFile(relativePath: Nullable<string>): Promise<void>;
            /**
                * Shows the directory of the given file and makes the file selected.
                * @param relativePath defines the path of the file to show relative to the assets directory.
                */
            showFile(relativePath: string): Promise<void>;
            /**
                * Calls the given function in all the selected items (if exists).
                * @param methodName defines the name of the function to call.
                * @hidden
                */
            _callSelectedItemsMethod(methodName: string, ...parameters: any[]): Promise<void>;
            /**
                * Returns the base64 string data of the preview for the asset at the given relative path.
                * @param relativePath defines the relative path to the item.
                */
            getAssetPreview(relativePath: string): Promise<string>;
            /**
                * Refreshes the current directory.
                */
            refresh(): Promise<void>;
            /**
                * Returns the list of all selected items.
                */
            get selectedFiles(): string[];
            /**
                * Returns wether or not the asset located at the given path is used.
                * @param path defines the path to the file to check if it's used.
                * @returns a boolean indicating if the asset in used in the project.
                */
            isAssetUsed(path: string): Promise<boolean>;
            /**
                * Returns the list of all available scripts.
                */
            getAllScripts(): Promise<string[]>;
            /**
                * Renames the given file by updating all known references.
                * @param absolutePath defines the absolute path to the file to rename.
                * @param newName defines the new name of the file to apply.
                */
            renameFile(absolutePath: string, newName: string): Promise<void>;
            /**
                * Moves all the selected items to trash and returns the list of failed items.
                * @param deleteOnFail defines wether or not the file should be deleted if failed to move to trash.
                */
            moveSelectedItemsToTrash(deleteOnFail: boolean): Promise<string[]>;
            /**
                * Moves all the given items to trash and returns the list of failed items.
                * @param deleteOnFail defines wether or not the file should be deleted if failed to move to trash.
                * @param items defines the list of all items to move to trash
                */
            moveItemsToTrash(deleteOnFail: boolean, items: string[]): Promise<string[]>;
            /**
                * Moves the currently selected items to the given destination folder (to)
                * @param to defines the absolute path to the folder where to move the asset.
                * @param items defines the optional list of items to move.
                */
            moveSelectedItems(to: string, items?: string[], renamedFolder?: string): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/preview' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Node, IParticleSystem, AbstractMesh, Sound, Observable, ReflectionProbe } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { ScenePicker } from "babylonjs-editor/renderer/editor/scene/picker";
    import { SceneGizmo, GizmoType } from "babylonjs-editor/renderer/editor/scene/gizmo";
    import { ScenePlayer } from "babylonjs-editor/renderer/play/inline-play";
    export enum PreviewFocusMode {
            Target = 1,
            Position = 2,
            Bottom = 4,
            Top = 8,
            Left = 16,
            Right = 32,
            Front = 64,
            Back = 128
    }
    export interface IPreviewProps {
            /**
                * The editor reference.
                */
            editor: Editor;
    }
    export interface IPreviewState {
            /**
                * Wether or not the canvas is focused or not.
                */
            canvasFocused: boolean;
            /**
                * The name of the node which is under the pointer.
                */
            overNodeName: string;
            /**
                * The current type of gizmo used in the preview.
                */
            gizmoType: GizmoType;
            /**
                * Defines the current used while using the gizmos.
                */
            gizmoStep: number;
            /**
                * Defines the list of all available gizmo steps.
                */
            availableGizmoSteps: number[];
            /**
                * Defines wether or not force wireframe is enabled or not.
                */
            forceWireframe: boolean;
            /**
                * Defines wether or not the icons should be drawn.
                */
            showIcons: boolean;
            /**
                * Defines wether or not the preview is in isolated mode.
                */
            isIsolatedMode: boolean;
            /**
                * Defines wether or not the user is playing the scene.
                */
            isPlaying: boolean;
            /**
                * Defines wether or not the user is playing the scene in a dedicated iframe.
                */
            isPlayingInIframe: boolean;
            /**
                * Defines the current play loading progress.
                */
            playLoadingProgress: number;
            /**
                * Defines wether or not the camera preview is visible.
                */
            cameraPreviewVisible: boolean;
    }
    export enum PreviewCanvasEventType {
            /**
                * Defines the event raised when the preview canvas is focused.
                */
            Focused = 0,
            /**
                * Defines the vent raised when the preview canvas is blurred.
                */
            Blurred = 1
    }
    export class Preview extends React.Component<IPreviewProps, IPreviewState> {
            /**
                * Defines the scene picker used to get/pick infos from the scene.
                */
            picker: ScenePicker;
            /**
                * Defines the scene gizmo manager.
                */
            gizmo: SceneGizmo;
            /**
                * Notifies observers that an event happened on the canvas.
                */
            onCanvasEventObservable: Observable<PreviewCanvasEventType>;
            /**
                * @hidden
                */
            _scenePlayer: ScenePlayer;
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IPreviewProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): Promise<void>;
            /**
                * Called on the user wants to play or stop the scene.
                * @param isPlayingInIframe defines wether or not the game is played in an isolated context using an iFrame.
                */
            playOrStop(isPlayingInIframe: boolean): Promise<void>;
            /**
                * Starts playing the scene in the editor.
                * @param isPlayingInIframe defines wether or not the game is played in an isolated context using an iFrame.
                * @throws
                */
            startPlayScene(isPlayingInIframe: boolean): Promise<void>;
            /**
                * Stops the game that is runnning in the editor.
                * @param isPlayingInIframe defines wether or not the game is played in an isolated context using an iFrame.
                */
            stopPlayingScene(isPlayingInIframe: boolean): Promise<void>;
            /**
                * In case the user is playing the test scene, it restarts the iframe.
                */
            restartPlay(): Promise<void>;
            /**
                * Toggles the isolated mode.
                */
            toggleIsolatedMode(object?: Nullable<AbstractMesh | IParticleSystem>): void;
            /**
                * Sets the new gizmo type to be used in the preview.
                * If the given gizmo type is the same as the current, it just sets the current type as "None".
                * @param gizmoType the new type of gizmo to be used in the preview.
                */
            setGizmoType(gizmoType: GizmoType): void;
            /**
                * Sets the current step used while using the gizmos.
                * @param gizmoStep the new step to use when using the current gizmo.
                */
            setGizmoStep(gizmoStep: number): void;
            /**
                * Toggles the force wireframe boolean for the current scene.
                */
            toggleWireframe(): void;
            /**
                * Togglets the scene icons for the current scene.
                */
            toggleShowIcons(): void;
            /**
                * Returns wether or not the canvas is focused.
                */
            get canvasFocused(): boolean;
            /**
                * Shows the search bar.
                */
            showSearchBar(): void;
            /**
                * Focuses the currently selected node.
                * @param mode defines the focus mode (animate target, position, etc.).
                */
            focusSelectedNode(mode: PreviewFocusMode): void;
            /**
                * Focuses the given node.
                * @param node defines the reference to the node to focus.
                * @param mode defines the focus mode (animate target, position, etc.).
                */
            focusNode(node: Node | IParticleSystem | Sound | ReflectionProbe, mode: PreviewFocusMode): void;
            /**
                * Copies the currently selected node.
                */
            copySelectedNode(): void;
            /**
                * Pastes the latest copied node.
                */
            pasteCopiedNode(): void;
            /**
                * Removes the currently selected node.
                */
            removeSelectedNode(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/main-toolbar' {
    import { Undefinable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Node } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { IPluginToolbar } from "babylonjs-editor/renderer/editor/plugins/toolbar";
    export interface IToolbarProps {
            /**
                * The editor reference.
                */
            editor: Editor;
    }
    export interface IToolbarState {
            /**
                * Defines wether or not the current project has a workspace. If true, the workspace tool will be shows.
                */
            hasWorkspace: boolean;
            /**
                * Defines wether or not the photoshop extension is enabled.
                */
            isPhotoshopEnabled: boolean;
            /**
                * Defines the list of all menus for plugins.
                */
            plugins?: Undefinable<IPluginToolbar[]>;
    }
    export class MainToolbar extends React.Component<IToolbarProps, IToolbarState> {
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IToolbarProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Returns the list of all items of the "Add" menu.
                */
            getAddMenuItems(parent?: Node): React.ReactNode;
            /**
                * Returns the list of all items of the "Add Mesh" menu.
                */
            getAddMeshMenuItem(parent?: Node): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/tools-toolbar' {
    import * as React from "react";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface IToolbarProps {
            /**
                * The editor reference.
                */
            editor: Editor;
    }
    export interface IToolbarState {
            /**
                * Defines wether or not project has a workspace loaded.
                */
            hasWorkspace: boolean;
            /**
                * Defines wether or not the user is playing the scene.
                */
            playing: {
                    /**
                        * Defines wether or not the user is playing.
                        */
                    isPlaying: boolean;
                    /**
                        * Defines wether or not the play is loading.
                        */
                    isLoading: boolean;
            };
    }
    export class ToolsToolbar extends React.Component<IToolbarProps, IToolbarState> {
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IToolbarProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the user wants to play or stop the test of the scene.
                */
            handlePlay(): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/console' {
    import * as React from "react";
    import { Observable } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { ConsoleLog } from "babylonjs-editor/renderer/editor/components/console/log";
    export interface IConsoleProps {
            /**
                * The editor reference.
                */
            editor: Editor;
    }
    export interface IConsoleState {
            /**
                * Defines the current width in pixels of the panel.
                */
            width: number;
            /**
                * Defines the current height in pixels of the panel.
                */
            height: number;
            /**
                * Defines the list of all available logs.
                */
            logs: React.ReactNode[];
    }
    export class Console extends React.Component<IConsoleProps, IConsoleState> {
            /**
                * Notifies all listeners that the logs have been resized.
                */
            onResizeObservable: Observable<void>;
            /**
                * Constructor.
                * @param props the component's props.
                */
            constructor(props: IConsoleProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component did update.
                */
            componentDidUpdate(): void;
            /**
                * Called on the panel has been resized.
                */
            resize(): void;
            /**
                * Logs the given message as info.
                * @param message defines the message to log as info.
                */
            logInfo(message: string): Promise<ConsoleLog>;
            /**
                * Logs the given message as warning.
                * @param message the message to log as warning.
                */
            logWarning(message: string): Promise<ConsoleLog>;
            /**
                * Logs the given message as error.
                * @param message the message to log as error.
                */
            logError(message: string): Promise<ConsoleLog>;
            /**
                * Logs the given message using separators. Allows to create sections in logs.
                * @param message defines the message to log directly.
                */
            logSection(message: string): Promise<ConsoleLog>;
            /**
                * Creates an empty log of type "Info" and returns its reference.
                */
            createLog(): Promise<ConsoleLog>;
            /**
                * Logs the given custom react component.
                * @param log defines the reference to the custom react component instance.
                */
            logCustom(log: React.ReactNode): void;
            /**
                * Clears the console.
                */
            clear(): void;
            /**
                * Overrides the current BabylonJS Logger class.
                */
            overrideLogger(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/workers/workers' {
    /**
        * Defines the type used to describe any constructor of any class.
        */
    export type AnyConstructor = (new (...args: any) => any);
    /**
        * Defines the type that describes the list of functions of T
        * where T should be a class.
        */
    export type FunctionPropertyNames<T> = {
            [K in keyof T]: T[K] extends Function ? K : never;
    }[keyof T];
    /**
        * In workers, called functions can be synchronous or asynchronous. This type
        * is used to the the return type of the function in the worker by removing the
        * promise type if asynchronous function.
        */
    export type Awaitable<T> = T extends PromiseLike<infer U> ? U : T;
    export interface IWorkerConfiguration {
            /**
                * Defines the reference to the effective worker.
                */
            worker: Worker;
    }
    export class Workers {
            /**
                * Defines the reference to the list of all loaded workers.
                */
            static Workers: IWorkerConfiguration[];
            /**
                * Loads a new Worker requiring the given JS path.
                * @param jsPath defines the path of the JS file to load relative to the "workers" folder.
                * @param parameters defines the parameters to pass to the constructor of the worker's loaded class.
                * @returns the reference to the worker configuration.
                */
            static LoadWorker<TClass extends AnyConstructor>(jsPath: string, ...parameters: ConstructorParameters<TClass>): Promise<IWorkerConfiguration>;
            /**
                * Executes the given function (fnName) in the worker's required class.
                * @param config defines the reference to the worker configuration previsouly loaded.
                * @param fnName defines the name of the function to execute in the main class.
                * @param parameters defines the parameters to send to the function called in the worker.
                * @returns the result of the function computed in the worker's context.
                */
            static ExecuteFunction<TClass extends Record<any, any>, TFunction extends FunctionPropertyNames<TClass>>(config: IWorkerConfiguration, fnName: TFunction, ...parameters: Parameters<TClass[TFunction]>): Promise<Awaitable<ReturnType<TClass[TFunction]>>>;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/utils' {
    import { IStringDictionary, Nullable } from "babylonjs-editor/shared/types";
    import { AbstractInspector } from "babylonjs-editor/renderer/editor/components/inspectors/abstract-inspector";
    export interface IInspectorSectionPreferences {
            /**
                * Defines the title of the section.
                */
            title: string;
            /**
                * Defines wether or not the section is collapsed.
                */
            collapsed: boolean;
    }
    export interface IInspectorPreferences {
            /**
                * Defines the list of sections preferences for the inspector.
                */
            sections: IInspectorSectionPreferences[];
    }
    export interface IInspectorComponentSearch {
            /**
                * Defines the title of the component.
                */
            title: string;
            /**
                * Defines the callback called on the user wants to filter components.
                * @param visible defines wether or not the component should be visible.
                */
            callback: (visible: boolean) => void;
    }
    export interface IInspectorNotifierUndoRedo<T> {
            /**
                * Defines the reference to the object that has been modified.
                */
            object: T;
            /**
                * Defines the name of the property that has been changed.
                */
            property: string;
            /**
                * Defines the old value of the property.
                */
            oldValue: any;
            /**
                * Defines the new value of the property.
                */
            newValue: any;
            /**
                * Defines wether or not the inspector is tagged as "no undo/redo".
                */
            noUndoRedo: boolean;
    }
    export class InspectorUtils {
            /**
                * Sets the current inspector being mounted.
                * @param inspector defines the reference to the current inspector being mounted.
                */
            static SetCurrentInspector(inspector: AbstractInspector<any, any>): string;
            /**
                * Gets the name of the current inspector being mounted.
                */
            static get CurrentInspectorName(): Nullable<string>;
            /**
                * Gets the reference to the current inspector being mounted.
                */
            static get CurrentInspector(): Nullable<AbstractInspector<any, any>>;
            /**
                * Sets registerd components visible or unvisible if their title match the given filter.
                * @param filter defines the current filter provided in the search input.
                * @param inspectorName defines the name of the inspector that performs a search.
                */
            static FilterComponents(filter: string, inspectorName: string): void;
            /**
                * Registers the given component to be part of the filterable components.
                * @param title defines the title of the section.
                * @param inspectorName defines the name of the inspector that contains the section to register.
                * @param callback defines the callback called on the filter changed (calling .FilterSections)
                */
            static RegisterFilterableComponent(title: string, inspectorName: string, callback: (visible: boolean) => void): void;
            /**
                * Saves the scroll value of the given inspector.
                * @param inspectorName defines the name of the inspector to save its scroll value.
                * @param scrollTop defines the value of the scrollTop property of the inspector.
                */
            static RegisterInspectorScroll(inspectorName: string, scrollTop: number): void;
            /**
                * Returns the value of the scroll for the given inspector in order to re-apply.
                * @param inspectorName defines the name of the inspector to retrieve its scroll value.
                */
            static GetInspectorScroll(inspectorName: string): number;
            /**
                * Returns the current preferences of the inspector identified by the given name.
                * @param inspectorName defines the name of the inspector to retrieve its preferences.
                */
            static GetInspectorPreferences(inspectorName?: Nullable<string>): Nullable<IInspectorPreferences>;
            /**
                * Returns wether or not the given section is collapsed.
                * @param title defines the title of the section to check in the inspector.
                * @param inspectorName defines the name of the inspector to retrieve.
                */
            static IsSectionCollapsed(title: string, inspectorName?: Nullable<string>): boolean;
            /**
                * Sets wether or not the given inspector section is collapsed.
                * @param title defines the title of the section to set collapsed or not.
                * @param collapsed defines wether or not the given section is collapsed.
                * @param inspectorName defines the name of the inspector to retrieve.
                */
            static SetSectionCollapsed(title: string, collapsed: boolean, inspectorName?: Nullable<string>): void;
            /**
                * Saves the current preferences.
                */
            static SavePreferencesToLocalStorage(): void;
            /**
                * Returns the current inspector preferences previously saved in the local storage.
                * In case of no preferences, an empty object is returned.
                */
            static GetPreferencesFromLocalStorage(): IStringDictionary<IInspectorPreferences>;
            /**
                * Registers the given callback called on a property ot the selected object changed.
                * @param inspectorName defines the name of the inspector to register.
                * @param callback defines the callback called on a property changed on the selected object.
                */
            static RegisterInspectorChangedListener(inspectorName: string, callback: (configuration: IInspectorNotifierUndoRedo<unknown>) => void): void;
            /**
                * Unregisters the callback of the given listener previously used to get notified when a property
                * of the selected object changed.
                * @param inspectorName defines the name of the inspector to remove its listener.
                */
            static UnregisterInspectorChangedListener(inspectorName: string): void;
            /**
                * Notifies the given inspector that the selected object has changed.
                * @param inspectorName defines the name of the inspector to notify.
                * @param configuration defines the reference to the undo/redo configuration.
                */
            static NotifyInspectorChanged(inspectorName: string, configuration: IInspectorNotifierUndoRedo<unknown>): void;
    }
}

declare module 'babylonjs-editor/renderer/sandbox/main' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Vector2, Vector3, Vector4, Color3, Color4, Quaternion } from "babylonjs";
    export interface IExportedInspectorValueOptions {
            /**
                * Defines the section of the inspector.
                */
            section?: string;
            /**
                * In case of numbers, defines the minimum value.
                */
            min?: number;
            /**
                * In case of numbers, defines the maximum value.
                */
            max?: number;
            /**
                * In case of numbers, defines the step applied in the editor.
                */
            step?: number;
            /**
                * In case of node, restricts the type of node that can be assigned
                */
            allowedNodeType?: "TransformNode" | "Mesh" | "Light" | "Camera";
    }
    export interface IExportedInspectorValue {
            /**
                * Defines the key in the class that has been decorated by @fromEditor.
                */
            propertyKey: string;
            /**
                * Defines the name of the property in the editor's inspector.
                */
            name: string;
            /**
                * Defines the default value of the decorated property.
                */
            defaultValue: number | string | boolean | Vector2 | Vector3 | Vector4 | Color3 | Color4 | Quaternion;
            /**
                * Defines the type of the decorated property.
                */
            type: "number" | "string" | "boolean" | "KeyMap" | "Vector2" | "Vector3" | "Vector4" | "Color3" | "Color4" | "Texture" | "Quaternion" | "Node";
            /**
                * Defines the optional options available for the exported value.
                */
            options?: IExportedInspectorValueOptions;
    }
    /**
        * Defines the main sandbox class used in the editor's renderer process.
        * Nodes in the scene can have scripts attached to them. A script can decorate properties (numbers, strings, vectors, etc.) using
        * decorators. In these decorators, the "@visibleInInspector" decorator is used to be able to customize the members directly in the editor.
        * As decorators are executed in runtime, we need to require/import the script attached to the node being modified in the scene.
        * To avoid having user scripts running in the same process as the editor, we use an iframe that will require/import these scripts and return
        * the desired objects.
        *
        * Example script:
        *  import { Mesh } from "@babylonjs/core";
        *
        *  // Import a lib that is not used by the editor.
        *  import { io } from "socket.io";
        *
        *  // Import decorators
        *  import { visibleInInspector } from "../tools";
        *
        *  export default class MyScript extends Mesh {
        *      @visibleInInspector("number", "Speed")
        *      public speed: number = null;
        *
        *      ...
        * }
        *
        * This script will be imported using "require("./myScript.js");"
        * Then, the decorators will be executed and will put the needed data in the MyScript class object.
        *
        * The only thing the iFrame has do do now, is to return the exported object of the require. Typically exports.default._InspectorValues.
        *
        * @see ./iframe.ts for more informations about require/import of scripts and returned values.
        */
    export class SandboxMain {
            /**
                * Inits the sandbox.
                */
            static Init(): Promise<void>;
            /**
                * Clears the require cache.
                */
            static ClearCache(path?: Nullable<string>): Promise<void>;
            /**
                * Requires the given file and returns all its decorator attributes.
                * @param path the path of the file to require.
                */
            static GetInspectorValues(path: string): Promise<IExportedInspectorValue[]>;
            /**
                * Executes the given code in the sandbox context.
                * @param code the code to execute.
                * @param name the name of the module.
                */
            static ExecuteCode(code: string, name: string): Promise<void>;
            /**
                * Returns the list of all constructors of the default class exported in the following TS file path.
                * @param path defines the path to the JS file.
                */
            static GetConstructorsList(path: string): Promise<string[]>;
    }
}

declare module 'babylonjs-editor/renderer/editor/gui/inspector/fields/abstract-field' {
    import * as React from "react";
    export class AbstractFieldComponent<P = {}, S = {}> extends React.Component<P, S> {
            /**
                * Gets wether or not the inspector component is mounted.
                */
            protected get isMounted(): boolean;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Called on the component will unmount.
                */
            componentWillUnmount(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/tools/ktx' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Engine } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    /**
        * Defines the possibile types of texture to be compressed.
        */
    export type KTXToolsType = "-astc.ktx" | "-dxt.ktx" | "-pvrtc.ktx" | "-etc1.ktx" | "-etc2.ktx";
    export class KTXTools {
            /**
                * Defines the list of all supported image types (extensions) for KTX compression using PVRTexTool.
                */
            static SupportedExtensions: string[];
            /**
                * Returns the format of the currently supported Ktx format.
                */
            static GetSupportedKtxFormat(engine: Engine): Nullable<KTXToolsType>;
            /**
                * Returns the list of all support Ktx formats.
                */
            static GetAllKtxFormats(): KTXToolsType[];
            /**
                * Returns the path to the CLI according to the current platform.
                */
            static GetCliPath(): Nullable<string>;
            /**
                * Returns the of the given texture path by applying the ktx extension to it.
                * @param texturePath defines the path to the texture to gets its Ktx name.
                * @param type defines the type of ktx file to use.
                */
            static GetKtxFileName(texturePath: string, type: KTXToolsType): string;
            /**
                * Compresses the given texture using the given texture compression type.
                * @param editor defines the reference to the editor.
                * @param texturePath defines the absolute path to the texture to compress.
                * @param destinationFolder defines the destination folder where the compressed texutre file will be written.
                * @param type defines compression type to apply on the texture.
                */
            static CompressTexture(editor: Editor, texturePath: string, destinationFolder: string, type: KTXToolsType): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/cinematic/cinematic' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { AnimationGroup, Scene } from "babylonjs";
    import { ICinematic, ICinematicCamera, ICinematicTrack } from "babylonjs-editor/renderer/editor/cinematic/base";
    export class Cinematic implements ICinematic {
            /**
                * @hidden
                */
            _animationGroup: Nullable<AnimationGroup>;
            /**
                * Plays the cinematic.
                */
            play(scene: Scene, from?: number): void;
            /**
                * Stops the cinematic.
                */
            stop(): void;
            /**
                * Generates the animation group and returns its reference.
                */
            generateAnimationGroup(scene: Scene): AnimationGroup;
            /**
                * Serializes the cinematic.
                */
            serialize(): ICinematic;
            /**
                * Parses the cinematic according the given parsed data.
                * @param parsedData defines the reference to object as JSON representation of cinematic.
                */
            static Parse(parsedData: ICinematic): Cinematic;
            /**
                * Defines the name of the cinematic.
                */
            name: string;
            /**
                * Defines the number of frames computed per second.
                */
            framesPerSecond: number;
            /**
                * Defines wether or not the cinematic is embedded in the file scene file output.
                */
            embedInSceneFile: boolean;
            /**
                * Defines the reference to the camera's configuration for the cinematic.
                */
            camera: ICinematicCamera;
            /**
                * Defines the list of all cinematic tracks.
                */
            tracks: ICinematicTrack[];
    }
}

declare module 'babylonjs-editor/renderer/editor/tools/process' {
    import { IPty } from "node-pty";
    import { Terminal, IDisposable } from "xterm";
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface IEditorProcess {
            /**
                * Defines the id of the process. This id is useful to get a process by id using the EditorProcess Api.
                * @see EditorProcess.GetProcessById
                */
            id: string;
            /**
                * Defines the reference to the node-pty process that is running.
                */
            program: IPty;
            /**
                * Defines the reference to the terminal that logs the process data.
                */
            terminal: Terminal;
            /**
                * Defines the options of the process.
                */
            options?: IEditorProcessOptions;
            /**
                * Defines the reference to the data listener.s
                */
            onDataListener?: IDisposable;
            /**
                * Defines wether or not the process has been killed.
                */
            killed: boolean;
            /**
                * Defines the function that waits until the process has finished.
                * This detaches the process from the list of available processes once finished.
                */
            wait: () => Promise<void>;
            /**
                * Kills the process and removes it from the listed editor processes.
                */
            kill: () => void;
    }
    export interface IEditorProcessOptions {
            /**
                * Defines the optional working directory.
                */
            cwd?: string;
            /**
                * Defines the optional command to write once the process has been created.
                */
            command?: string;
            /**
                * Defines the reference to the terminal that logs the process data.
                */
            terminal?: Terminal;
            /**
                * Defines wether or not the process is readonly mode.
                */
            readonly?: boolean;
    }
    export class EditorProcess {
            /**
                * Registers a new process to the editor identified by the given id with the given options.
                * If the process already exists, returns the reference to the existing editor process object.
                * @param editor defines the reference to the editor.
                * @param id defines the id of the process.
                * @param options defines the optional options that can be passed to the process and terminal.
                * @returns the newly created editor process object that contains the terminal, process, etc.
                * @example EditorProcess.RegisterProcess(editor, "watch-webpack", { cwd: WorkSpace.DirPath, command: "npm run watch" });
                */
            static RegisterProcess(editor: Nullable<Editor>, id: string, options?: IEditorProcessOptions): Nullable<IEditorProcess>;
            /**
                * Restarts the process identified by the given id if exists.
                * @param editor defines the reference to the editor.
                * @param id defines the id of the process to restart if exists.
                */
            static RestartProcessById(editor: Editor, id: string): void;
            /**
                * Executes the given command and returns the reference to the newly created editor process object.
                * @param command defines the command to execute in the terminal process.
                * @param readonly defines wether or not the terminal process is in read-only.
                * @param cwd defines the absolute path to the working directory where to process will be executed.
                * @returns the newly created editor process object that contains the terminal, process, etc.
                */
            static ExecuteCommand(command: string, readonly?: boolean, cwd?: string): Nullable<IEditorProcess>;
            /**
                * Kills and removes the editor process identified by the given id if exists.
                * @param id defines the id of the editor process to remove if exists.
                */
            static RemoveProcessById(id: string): void;
            /**
                * Creates a new terminal and returns its reference.
                */
            static CreateTerminal(): Terminal;
            /**
                * Returns the reference to the editor process identified by the given id if exists.
                * @param id defines the id of the process to retrieve if exists.
                * @returns the reference to the editor process object if exists.
                */
            static GetProcessById(id: string): Nullable<IEditorProcess>;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/assets-browser/tree' {
    import * as React from "react";
    import { ITreeNode } from "@blueprintjs/core";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export interface IAssetsBrowserFavorite {
            /**
                * Defines the id of the favorite.
                */
            id: string;
            /**
                * Defines the name of the favorite.
                */
            name: string;
    }
    export interface IAssetsBrowserTreeProps {
            /**
                * Defines the reference to the editor.
                */
            editor: Editor;
            /**
                * Defines the callback called on a directory has been clicked in the tree.
                */
            onDirectorySelected: (path: string) => void;
            /**
                * Defines the callback called on a favorite has been clicked in the tree.
                */
            onFavoriteSelected: (favorite: IAssetsBrowserFavorite) => void;
    }
    export interface IAssetsBrowserTreeState {
            /**
                * Defines the list of all available nodes in the tree.
                */
            nodes: ITreeNode<string>[];
    }
    export class AssetsBrowserTree extends React.Component<IAssetsBrowserTreeProps, IAssetsBrowserTreeState> {
            /**
                * Defines the id of the node for favorites "Textures".
                */
            static readonly TexturesFavorite: IAssetsBrowserFavorite;
            /**
                * Defines the id of the node for favorites "Materials".
                */
            static readonly MaterialsFavorite: IAssetsBrowserFavorite;
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IAssetsBrowserTreeProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Sets the new absolute path to the directory to read and draw its items.
                * @param directoryPath defines the absolute path to the directory to show in the view.
                */
            setDirectory(directoryPath: string): Promise<void>;
            /**
                * Refreshes the current tree.
                */
            refresh(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/assets-browser/files' {
    import * as React from "react";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { IAssetsBrowserFavorite } from "babylonjs-editor/renderer/editor/components/assets-browser/tree";
    import { AssetsBrowserItem } from "babylonjs-editor/renderer/editor/components/assets-browser/files/item";
    export interface IAssetsBrowserFilesProps {
            /**
                * Defines the reference to the editor.
                */
            editor: Editor;
            /**
                * Defines the callback called on a directory has been clicked in the tree.
                */
            onDirectorySelected: (path: string) => void;
    }
    export interface IAssetsBrowserFilesState {
            /**
                * Defines the current stack of opened folders.
                */
            pathStack: string[];
            /**
                * Defines the absolute path to the working directory.
                */
            currentDirectory: string;
            /**
                * Defines the current filter.
                */
            filter: string;
            /**
                * Defines the current size value for the items.
                */
            itemsSize: number;
            /**
                * Defines the list of all items drawn in the view.
                */
            items: React.ReactNode[];
    }
    export class AssetsBrowserFiles extends React.Component<IAssetsBrowserFilesProps, IAssetsBrowserFilesState> {
            /**
                * Defines the list of all selected items.
                */
            selectedItems: string[];
            /** @internal */
            _assetsDirectory: string;
            /** @internal */
            _sourcesDirectory: string;
            /**
                * @hidden
                */
            _items: AssetsBrowserItem[];
            /**
                * Initializes the files component.
                * @param editor defines the reference to the editor.
                */
            static Init(editor: Editor): Promise<void>;
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IAssetsBrowserFilesProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Returns the list of all items drawn in the "Add..." menu.
                */
            getAddMenuItems(): React.ReactNode;
            /**
                * Sets the new favorite to read and draw its items.
                * @param favorite defines the id of the favorite to show in the view.
                */
            setFavorite(favorite: IAssetsBrowserFavorite): Promise<void>;
            /**
                * Sets the new absolute path to the directory to read and draw its items.
                * @param directoryPath defines the absolute path to the directory to show in the view.
                */
            setDirectory(directoryPath: string): Promise<void>;
            /**
                * Refreshes the current list of files.
                */
            refresh(): Promise<void>;
            /**
                * Refreshes the preview thmbnail of the asset located at the given relative path.
                * @param relativePath defines the relative path to the asset.
                */
            refreshItemPreview(relativePath: string): Promise<void>;
            /**
                * Calls the given function in all the selected items (if exists).
                * @param methodName defines the name of the function to call.
                * @hidden
                */
            _callSelectedItemsMethod(methodName: string, ...parameters: any[]): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/scene/picker' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Observable, Node, SubMesh } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { SceneIcons } from "babylonjs-editor/renderer/editor/scene/icons";
    export class ScenePicker {
            /**
                * Notifies users when the
                */
            onNodeOver: Observable<Node>;
            /**
                * Defines the reference to the scene icons.
                */
            icons: SceneIcons;
            /**
                * Defines wether or not an overlay is drawn on the elements over the user's mouse.
                */
            drawOverlayOnOverElement: boolean;
            /**
                * Constructor.
                * @param editor the editor reference.
                */
            constructor(editor: Editor);
            /**
                * Resets the picker.
                */
            reset(): void;
            /**
                * Called on the mouse exists the canvas.
                */
            canvasBlur(): void;
            /**
                * Returns the reference of the mesh that is under the pointer.
                * @param fastCheck Launch a fast check only using the bounding boxes. Can be set to null.
                */
            getObjectUnderPointer(fastCheck?: boolean): Nullable<Node | SubMesh>;
    }
}

declare module 'babylonjs-editor/renderer/editor/scene/gizmo' {
    import { UtilityLayerRenderer, Node, IParticleSystem, Sound, ReflectionProbe } from "babylonjs";
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export enum GizmoType {
            None = 0,
            Position = 1,
            Rotation = 2,
            Scaling = 3
    }
    export class SceneGizmo {
            _gizmosLayer: UtilityLayerRenderer;
            /**
                * Constructor.
                */
            constructor(editor: Editor);
            /**
                * Returns the current type of gizmo being used in the preview.
                */
            get gizmoType(): GizmoType;
            /**
                * Sets the type of gizm to be used in the preview.
                */
            set gizmoType(type: GizmoType);
            /**
                * Returns the current step used while using the gizmos.
                */
            get gizmoStep(): number;
            /**
                * Sets the current step used while using the gizmos.
                */
            set gizmoStep(steps: number);
            /**
                * Sets the given node attached to the current gizmos if exists.
                * @param node the node to attach to current gizmos if exists.
                */
            setAttachedNode(node: Nullable<Node | IParticleSystem | Sound | ReflectionProbe>): void;
    }
}

declare module 'babylonjs-editor/renderer/play/inline-play' {
    import { Nullable } from "babylonjs-editor/shared/types";
    import { Scene } from "babylonjs";
    import Editor from "babylonjs-editor/renderer/editor";
    export class ScenePlayer {
            /**
                * @hidden
                */
            _scene: Nullable<Scene>;
            /**
                * Constructor.
                * @param editor defines the reference to the editor.
                */
            constructor(editor: Editor);
            /**
                * Starts playing the scene in the editor: load the scene, apply attached scripts and return the reference to the scene.
                */
            start(progress: (p: number) => void): Promise<Scene>;
            /**
                * Starts rendering the play scene in the editor.
                */
            runRenderLoop(): void;
            /**
                * Disposes the scene player by disposing the play scene, clear scene's scripts require cache
                * and reset the engine's cache.
                */
            dispose(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/components/console/log' {
    import * as React from "react";
    export enum ConsoleLogType {
            /**
                * Just for information.
                */
            Info = 0,
            /**
                * Shows a warning.
                */
            Warning = 1,
            /**
                * Shows an error.
                */
            Error = 2
    }
    export interface IConsoleLog {
            /**
                * The type of the message.
                */
            type: ConsoleLogType;
            /**
                * The message in the log.
                */
            message: string;
            /**
                * Defines wether or not a separator should be drawn.
                */
            separator?: boolean;
    }
    export interface IConsoleLogProps extends IConsoleLog {
    }
    export interface IConsoleLogState {
            /**
                * Defines the message of the log.
                */
            message: string;
            /**
                * Defines the reference to the custom log body.
                */
            body?: React.ReactNode;
    }
    export class ConsoleLog extends React.Component<IConsoleLogProps, IConsoleLogState> {
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IConsoleLogProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Sets the new message of the log.
                * @param message defines the message of the log.
                */
            setMessage(message: string): void;
            /**
                * Sets the new body of the log.
                * @param body defines the reference to the custom body.
                */
            setBody(body: React.ReactNode): Promise<void>;
    }
}

declare module 'babylonjs-editor/renderer/editor/cinematic/base' {
    import { CinematicTrackType, ICinematicAnimationGroupTrack, ICinematicPropertyGroupTrack, ICinematicPropertyTrack, ICinematicTrackGroup } from "babylonjs-editor/renderer/editor/cinematic/track";
    export interface ICinematicCamera {
            /**
                * Defines the id of the camera used for the cinematic.
                */
            cameraId: string;
            /**
                * Defines the list of animation keys for camera's fov.
                */
            fov: ICinematicTrack;
            /**
                * Defines the list of animation keys for camera's position.
                */
            position: ICinematicTrack;
            /**
                * Defines the list of animation keys for camera's target.
                */
            target: ICinematicTrack;
            /**
                * Defines the list of animation keys for camera's DOF focus distance.
                */
            focusDistance: ICinematicTrack;
            /**
                * Defines the list of animation keys for camera's DOF F-Stop.
                */
            fStop: ICinematicTrack;
            /**
                * Defines the list of animation keys for camera's DOF focal length.
                */
            focalLength: ICinematicTrack;
    }
    export interface ICinematicTrack {
            /**
                * Defines the type of the cinematic track.
                */
            type: CinematicTrackType;
            /**
                * In case of group, defines the configuration of the group.
                */
            group?: ICinematicTrackGroup;
            /**
                * In case of property track, defines the configuration of the animated property.
                */
            property?: ICinematicPropertyTrack;
            /**
                * In case of property group track, defines the configuration of the animated property for multiple nodes.
                */
            propertyGroup?: ICinematicPropertyGroupTrack;
            /**
                * In case of animation group track, defines the configuration of the animation group.
                */
            animationGroup?: ICinematicAnimationGroupTrack;
    }
    export interface ICinematic {
            /**
                * Defines the name of the cinematic.
                */
            name: string;
            /**
                * Defines the number of frames computed per second for the cinematic.
                */
            framesPerSecond: number;
            /**
                * Defines wether or not the cinematic is embedded in the file scene file output.
                */
            embedInSceneFile?: boolean;
            /**
                * Defines the reference to the camera's configuration for the cinematic.
                */
            camera: ICinematicCamera;
            /**
                * Defines the list of all cinematic tracks.
                */
            tracks: ICinematicTrack[];
    }
}

declare module 'babylonjs-editor/renderer/editor/components/assets-browser/files/item' {
    import { IStringDictionary, Nullable } from "babylonjs-editor/shared/types";
    import * as React from "react";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    import { AssetsBrowserItemHandler, IItemHandler } from "babylonjs-editor/renderer/editor/components/assets-browser/files/item-handler";
    import { AssetsBrowserMoveHandler } from "babylonjs-editor/renderer/editor/components/assets-browser/files/move/move-handler";
    export interface IAssetsBrowserItemProps {
            /**
                * Defines the reference to the editor.
                */
            editor: Editor;
            /**
                * Defines the title of the item.
                */
            title: string;
            /**
                * Defines the relative path to the item.
                */
            relativePath: string;
            /**
                * Defines the absolute path to the item.
                */
            absolutePath: string;
            /**
                * Defines the type of the item (directory or file).
                */
            type: "file" | "directory";
            /**
                * Defines the size of the item.
                */
            size?: number;
            /**
                * Defines the callback called each time the item is clicked.
                */
            onClick: (item: AssetsBrowserItem, ev: React.MouseEvent<HTMLDivElement>) => void;
            /**
                * Callback called on the user double clicks an item.
                */
            onDoubleClick: () => void;
            /**
                * Defines the callback called on the item is starts being dragged.
                */
            onDragStart: (item: AssetsBrowserItem, ev: React.DragEvent<HTMLDivElement>) => void;
    }
    export interface IAssetsBrowserItemState {
            /**
                * Defines the color applied on the title.
                */
            titleColor: string;
            /**
                * Defines wether or not the item is selected.
                */
            isSelected: boolean;
            /**
                * Defines wether or not the file is being renamed.
                */
            isRenaming: boolean;
            /**
                * Defines the reference to the item handler.
                */
            itemHandler: Nullable<React.ReactNode>;
            /**
                * Defines the size of the item.
                */
            size: number;
    }
    export class AssetsBrowserItem extends React.Component<IAssetsBrowserItemProps, IAssetsBrowserItemState> {
            /**
                * @hidden
                */
            static _ItemHandlers: IStringDictionary<IItemHandler>;
            /**
                * @hidden
                */
            static _ItemMoveHandlers: AssetsBrowserMoveHandler[];
            /**
                * Registers the given item handler.
                * @param itemHandler defines the reference to the configuration of the item handler.
                */
            static RegisterItemHandler(itemHandler: IItemHandler): void;
            /**
                * Registers the given item move handler.
                * @param itemMoveHandler defines the reference to the item move handler.
                */
            static RegisterItemMoveHandler(itemMoveHandler: AssetsBrowserMoveHandler): void;
            /**
                * Initializes the item renderer.
                */
            static Init(editor: Editor): void;
            /**
                * @hidden
                */
            _itemHandlerRef: Nullable<AssetsBrowserItemHandler>;
            /**
                * Constructor.
                * @param props defines the component's props.
                */
            constructor(props: IAssetsBrowserItemProps);
            /**
                * Renders the component.
                */
            render(): React.ReactNode;
            /**
                * Called on the component did mount.
                */
            componentDidMount(): void;
            /**
                * Sets wether or not the item is selected.
                * @param isSelected defines wether or not the item is selected.
                */
            setSelected(isSelected: boolean): void;
    }
}

declare module 'babylonjs-editor/renderer/editor/scene/icons' {
    import { UtilityLayerRenderer, Observable } from "babylonjs";
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export class SceneIcons {
            /**
                * Notifies the obersers that an icon has been clicked.
                */
            onClickObservable: Observable<MouseEvent>;
            /**
                * @hidden
                */
            _layer: UtilityLayerRenderer;
            /**
                * Constructor.
                * @param editor the editor reference.
                */
            constructor(editor: Editor);
            /**
                * Gets wether or not the icons should be rendered.
                */
            get enabled(): boolean;
            /**
                * Sets wether or not the icons should be rendered.
                */
            set enabled(enabled: boolean);
            /**
                * Refreshes the scene icons.
                */
            refresh(): void;
            /**
                * Disposes the scene icons.
                */
            dispose(): void;
    }
}

declare module 'babylonjs-editor/renderer/editor' {
    import { Editor } from "babylonjs-editor/renderer/editor/editor";
    export default Editor;
}

declare module 'babylonjs-editor/renderer/editor/cinematic/track' {
    import { IAnimationKey } from "babylonjs";
    import { ICinematicTrack } from "babylonjs-editor/renderer/editor/cinematic/base";
    export enum CinematicTrackType {
            Group = "group",
            Property = "property",
            PropertyGroup = "propertyGroup",
            AnimationGroup = "animationGroup"
    }
    export interface ICinematicTrackGroup {
            /**
                * Defines the name of the group.
                */
            name: string;
            /**
                * Defines the array of tracks.
                */
            tracks: ICinematicTrack[];
    }
    export interface ICinematicAnimationGroupSlot {
            /**
                * Defines the position of the slot in the timeline expressed in pixels.
                */
            position: number;
            /**
                * Defines the end frame of the track in the animation group.
                */
            end: number;
            /**
                * Defines the start frame of the track in the animation group.
                */
            start: number;
    }
    export interface ICinematicAnimationGroupTrack {
            /**
                * Defines the name of the animation group to play.
                */
            name: string;
            /**
                * Defines the list of all animation group slots.
                */
            slots: ICinematicAnimationGroupSlot[];
    }
    export interface ICinematicPropertyTrackBase {
            /**
                * Define the path of the animated property.
                */
            propertyPath: string;
            /**
                * Defines the list of all animation keys.
                */
            keys: IAnimationKey[];
            /**
                * Defines the type of the property being animated (float, vector3, etc.).
                * @see BABYLON.Animation.XType
                */
            animationType: number;
    }
    export interface ICinematicPropertyTrack extends ICinematicPropertyTrackBase {
            /**
                * Defines the id of the node being animated.
                */
            nodeId: string;
    }
    export interface ICinematicPropertyGroupTrack extends ICinematicPropertyTrackBase {
            /**
                * Defines the list of all nodes being animated.
                */
            nodeIds: string[];
    }
}

