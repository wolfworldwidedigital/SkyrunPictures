"use strict";
/**
 * Generated by the Babylon.JS Editor v4.7.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsGraphAttached = exports.IsGraph = void 0;
var core_1 = require("@babylonjs/core");
/**
 * Tells that this script has been generated by a graph.
 */
exports.IsGraph = true;
/**
 * Tells wether or not the graph has been attached to at least one node or not.
 */
exports.IsGraphAttached = false;
/**
 * Defines the generated class of the graph.
 */
var GraphClass = /** @class */ (function () {
    /**
     * Constructor.
     * @param scene defines the scene where the graph is running.
     */
    function GraphClass(_scene, _attachedObject) {
        this._scene = _scene;
        this._attachedObject = _attachedObject;
        this.ball = this._scene.getMeshByName("ball");
        this.camera = this._scene.getCameraByName("camera");
        this.gunshot = this._scene.getSoundByName("sounds/gunshot.wav");
        this.bounce = this._scene.getSoundByName("sounds/bounce.wav");
    }
    /**
     * Called on the scene starts.
     */
    GraphClass.prototype.onStart = function () {
        var _this = this;
        this._scene.onPointerObservable.add(function (ev) {
            if (ev.type !== core_1.PointerEventTypes.POINTERDOWN) {
                return;
            }
            var meshInstance_3 = _this.ball.createInstance("ball instance");
            meshInstance_3.position = _this.ball.absolutePosition;
            meshInstance_3.physicsImpostor = new core_1.PhysicsImpostor(meshInstance_3, core_1.PhysicsImpostor.SphereImpostor, {
                mass: 1,
                friction: 0.2,
                restitution: 0.2,
            });
            meshInstance_3.applyImpulse(_this.camera.getDirection(new core_1.Vector3(0, 0, 30)), meshInstance_3.position);
            _this.gunshot.play();
            var timeoutId_3 = setTimeout(function () {
                meshInstance_3.dispose(true, false);
                _this.bounce.play();
            }, 1000);
        });
    };
    /**
     * Called each frame.
     */
    GraphClass.prototype.onUpdate = function () {
    };
    /**
     * Returns the reference to the current scene the graph is running.
     */
    GraphClass.prototype.getScene = function () {
        return this._scene;
    };
    /**
     * Returns the reference to the object the graph is attached to.
     */
    GraphClass.prototype.getAttachedObject = function () {
        return this._attachedObject;
    };
    return GraphClass;
}());
exports.default = GraphClass;
//# sourceMappingURL=graphs_launchBall.graph.js.map